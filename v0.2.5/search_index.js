var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"background/lsrk/#Low-storage-Runge–Kutta-methods","page":"Low-storage Runge–Kutta methods","title":"Low-storage Runge–Kutta methods","text":"","category":"section"},{"location":"background/lsrk/","page":"Low-storage Runge–Kutta methods","title":"Low-storage Runge–Kutta methods","text":"LSRK methods are self-starting, with U^(1) = u^n, and then using stage updates of the form","category":"page"},{"location":"background/lsrk/","page":"Low-storage Runge–Kutta methods","title":"Low-storage Runge–Kutta methods","text":"beginaligned\ndU^(i) = f(U^(i) t + c_i Delta t) + A_i dU^(i-1)\nU^(i+1) = U^(i) + Delta t B_i dU^(i)\nendaligned","category":"page"},{"location":"background/lsrk/","page":"Low-storage Runge–Kutta methods","title":"Low-storage Runge–Kutta methods","text":"where A_1 = c_1 = 0 (implying dU^(1) = f(u^n t)), with the value at the next step being the N+1th stage value u^n+1 = U^(N+1)).","category":"page"},{"location":"background/lsrk/","page":"Low-storage Runge–Kutta methods","title":"Low-storage Runge–Kutta methods","text":"This allows the updates to be performed with only two copies of the state vector (so long as f can be evaluated in incrementing form).","category":"page"},{"location":"background/lsrk/","page":"Low-storage Runge–Kutta methods","title":"Low-storage Runge–Kutta methods","text":"It can be written as an RK scheme with Butcher tableau coefficients defined by the recurrences","category":"page"},{"location":"background/lsrk/","page":"Low-storage Runge–Kutta methods","title":"Low-storage Runge–Kutta methods","text":"beginaligned\na_ii = 0 \na_ij = B_j + A_j+1 a_ij+1\nb_N = B_N \nb_i = B_i + A_i+1 b_i+1\nendaligned","category":"page"},{"location":"background/lsrk/","page":"Low-storage Runge–Kutta methods","title":"Low-storage Runge–Kutta methods","text":"or equivalently","category":"page"},{"location":"background/lsrk/","page":"Low-storage Runge–Kutta methods","title":"Low-storage Runge–Kutta methods","text":"beginaligned\na_jj = 0 \na_ij = a_i-1j + B_i-1 prod_k=j+1^i-1 A_k\nendaligned","category":"page"},{"location":"background/lsrk/","page":"Low-storage Runge–Kutta methods","title":"Low-storage Runge–Kutta methods","text":"with b_j treated analogously as a_N+1j.","category":"page"},{"location":"background/mrrk/#Multirate-Runge-Kutta","page":"Multirate Runge Kutta","title":"Multirate Runge Kutta","text":"","category":"section"},{"location":"background/mrrk/","page":"Multirate Runge Kutta","title":"Multirate Runge Kutta","text":"Given a problem with two components that operate at two rates:","category":"page"},{"location":"background/mrrk/","page":"Multirate Runge Kutta","title":"Multirate Runge Kutta","text":"fracdudt = f_F(ut) + f_S(ut)","category":"page"},{"location":"background/mrrk/","page":"Multirate Runge Kutta","title":"Multirate Runge Kutta","text":"where f_F is the fast component, and f_S is the slow component.","category":"page"},{"location":"background/mrrk/","page":"Multirate Runge Kutta","title":"Multirate Runge Kutta","text":"M. Schlegel, O. Knoth, M. Arnold, R. Wolke (2012) defines the following method.","category":"page"},{"location":"background/mrrk/","page":"Multirate Runge Kutta","title":"Multirate Runge Kutta","text":"Given an outer explicit Runge–Kutta scheme with tableau (abc)","category":"page"},{"location":"background/mrrk/","page":"Multirate Runge Kutta","title":"Multirate Runge Kutta","text":"We can define the stage values U^(i) = v_i(tau_i) as the solution to the inner ODE problem","category":"page"},{"location":"background/mrrk/","page":"Multirate Runge Kutta","title":"Multirate Runge Kutta","text":"fracdv_idtau\n  = sum_j=1^i  fraca_ij - a_i-1jc_i - c_i-1  f_S (U^(j) tau_j)\n    + f_F(v_i tau)\nquad tau in tau_i-1 tau","category":"page"},{"location":"background/mrrk/","page":"Multirate Runge Kutta","title":"Multirate Runge Kutta","text":"where tau_i = t + Delta t c_i, with initial condition v_i(tau_i-1) = U^(i-1). If c_i == c_i-1, we can treat it as a correction step:","category":"page"},{"location":"background/mrrk/","page":"Multirate Runge Kutta","title":"Multirate Runge Kutta","text":"U^(i) = U^(i-1) + Delta t fracsum_j=1^i (a_ij - a_i-1j)c_i - c_i-1 f_S (U^(j) tau_i)","category":"page"},{"location":"background/mrrk/","page":"Multirate Runge Kutta","title":"Multirate Runge Kutta","text":"The final summation stage treating analogously to i=N+1, with a_N+1j = b_j and c_N+1 = 1.","category":"page"},{"location":"background/mrrk/#Low-storage","page":"Multirate Runge Kutta","title":"Low-storage","text":"","category":"section"},{"location":"background/mrrk/","page":"Multirate Runge Kutta","title":"Multirate Runge Kutta","text":"If using a low-storage Runge–Kutta method is used as an outer solver, then this reduces to","category":"page"},{"location":"background/mrrk/","page":"Multirate Runge Kutta","title":"Multirate Runge Kutta","text":"fracdv_idtau\n  =  fracB_i-1c_i - c_i-1 dU_S^(i-1)\n    + f_F(v_i tau)\nquad tau in tau_i-1 tau","category":"page"},{"location":"background/mrrk/","page":"Multirate Runge Kutta","title":"Multirate Runge Kutta","text":"where","category":"page"},{"location":"background/mrrk/","page":"Multirate Runge Kutta","title":"Multirate Runge Kutta","text":"dU_S^(i) = f_S(U^(i) tau_i) + A_i dU_S^(i-1)","category":"page"},{"location":"background/mrrk/#Multirate-Infinitesimal-Step-(MIS)","page":"Multirate Runge Kutta","title":"Multirate Infinitesimal Step (MIS)","text":"","category":"section"},{"location":"background/mrrk/","page":"Multirate Runge Kutta","title":"Multirate Runge Kutta","text":"Multirate Infinitesimal Step (MIS) methods (J{\\\"o}rg Wensch, Oswald Knoth, Alexander Galant (2009), Oswald Knoth, Joerg Wensch (2014))","category":"page"},{"location":"background/mrrk/","page":"Multirate Runge Kutta","title":"Multirate Runge Kutta","text":"beginaligned\nv_i (0)\n  = u^n + sum_j=1^i-1 alpha_ij (U^(j) - u^n)\n\nfracdv_idtau\n  = sum_j=1^i-1 fracgamma_ijd_i Delta t (U^(j) - u^n)\n    + sum_j=1^i fracbeta_ijd_i f_S (U^(j) t + Delta t c_i)\n    + f_F(v_i t^n +  Delta t tilde c_i + fracc_i - tilde c_id_i tau)\nquad tau in 0 Delta t d_i\n\nU^(i) = v_i(Delta t d_i)\nendaligned","category":"page"},{"location":"background/mrrk/","page":"Multirate Runge Kutta","title":"Multirate Runge Kutta","text":"The method is defined in terms of the lower-triangular matrices alpha, beta and gamma, with d_i = sum_j beta_ij, c_i = (I - alpha - gamma)^-1 d and tilde c = alpha c.","category":"page"},{"location":"background/mrrk/#Wicker-Skamarock","page":"Multirate Runge Kutta","title":"Wicker Skamarock","text":"","category":"section"},{"location":"background/mrrk/","page":"Multirate Runge Kutta","title":"Multirate Runge Kutta","text":"Louis J Wicker, William C Skamarock (1998) and Louis J Wicker, William C Skamarock (2002) define RK2 and RK3 multirate schemes:","category":"page"},{"location":"background/mrrk/","page":"Multirate Runge Kutta","title":"Multirate Runge Kutta","text":"beginaligned\nv_i (t) = u^n\n\nfracdv_idtau\n  = f_S (U^(i-1) t + Delta t c_i-1)\n    + f_F(v_i tau)\nquad tau in t t+ Delta t c_i \n\nU^(i) = v_i(t + Delta t c_i)\nendaligned","category":"page"},{"location":"background/mrrk/","page":"Multirate Runge Kutta","title":"Multirate Runge Kutta","text":"which corresponds to an MIS method with alpha = gamma = 0 and beta = operatornamediag(c).","category":"page"},{"location":"background/ark/#Additive-Runge–Kutta","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"","category":"section"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"ARK methods are IMEX (Implicit-Explicit) methods based on splitting the ODE function f(u) = f_L(u) + f_R(t)  where f_L(u) = L u is a linear operator which is treated implicitly, and f_R(u) is the remainder to be treated explicitly. Typically we will be given either the pair (f_R f_L), which we will term the remainder form, or (f f_L) which we will term the full form. ","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"The value on the ith stage U^(i) is","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"U^(i) = u^n + Delta t sum_j=1^i tilde a_ij f_L(U^(j)) \n              + Delta t sum_j=1^i-1 a_ij f_R(U^(j))","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"which can be written as the solution to the linear problem:","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"W U^(i) = hat U^(i)","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"where","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"hat U^(i) = u^n + Delta t sum_j=1^i-1 tilde a_ij f_L(U^(j)) \n                                             + Delta t sum_j=1^i-1 a_ij f_R(U^(j))","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"and","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"W = (I - Delta t tilde a_ii L)","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"The next step is then defined as","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"u^n+1 = u^n + Delta t sum_i=1^N b_i  f_L(U^(i)) + f_R(U^(i)) ","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"When an iterative solver is used, an initial value bar U^(i) can be chosen by an explicit approximation","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"bar U^(i) = u^n + Delta t sum_j=1^i-1 a_ij  f_L(U^(j)) + f_R(U^(j)) \n            = hat U^(i) + Delta t sum_j=1^i-1 (a_ij - tilde a_ij)  f_L(U^(j)) ","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"By convention, tilde a_11 = 0, so that U^(1) = u^n, and for all other stages the implicit coefficients tilde a_ii are the same. ","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"If the linear operator L is time-invariant and Delta t is constantm, then if using a direct solver, W only needs to be factorized once.","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"Alternatively if an iterative solver is used used, we can write","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"bar U^(i) = u^n + Delta t sum_j=1^i-1 a_ij  f_L(U^(j)) + f_R(U^(j)) \n            = hat U^(i) + Delta t  L sum_j=1^i-1 (a_ij - tilde a_ij)  U^(j)","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"at the cost of one evaluation of f_L.","category":"page"},{"location":"background/ark/#Reducing-evaluations-and-storage","page":"Additive Runge–Kutta","title":"Reducing evaluations and storage","text":"","category":"section"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"If the linear operator L is constant, then we are able to avoid evaluating the f_L explicitly.","category":"page"},{"location":"background/ark/#Remainder-form","page":"Additive Runge–Kutta","title":"Remainder form","text":"","category":"section"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"If we are given f_L and f_R, we can avoid storing f_L(U^(j)) by further defining","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"Omega^(i) = sum_j=1^i-1 fractilde a_ijtilde a_ii U^(j)","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"and writing","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"hat U^(i) = u^n + Delta t tilde a_ii f_L( Omega^(i) ) + Delta t sum_j=1^i-1 a_ij f_R(U^(j))","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"This can be rewritten into an offset linear problem","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"W V^(i) = hat V^(i)","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"where","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"V^(i) = U^(i) + Omega^(i)","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"and","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"hat V^(i)\n  = hat U_(i) + (I - Delta t tilde a_ii L)  Omega^(i) \n  = u^n + Omega^(i) + Delta t sum_j=1^i-1 a_ij f_R(U^(j))","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"If using an iterative method, an initial guess is","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"bar V^(i) = bar U^(i) + Omega^(i)\n  = u^n + Delta t sum_j=1^i-1 a_ij f_R(U^(j)) + Omega^(i) + Delta t sum_j=1^i-1 a_ij f_L(U^(j))\n  = hat V^(i) + Delta t L sum_j=1^i-1 a_ij U^(j)","category":"page"},{"location":"background/ark/#Full-form","page":"Additive Runge–Kutta","title":"Full form","text":"","category":"section"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"Similary, if we are given f and f_L, we can avoid storing f_L(U^(j)) by defining","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"Omega^(i) = sum_j=1^i-1 fractilde a_ij - a_ijtilde a_ii U^(j)","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"so that we can write","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"hat U^(i) = u^n + Delta t tilde a_ii f_L(Omega^(i)) + Delta t sum_j=1^i-1 a_ij f(U^(j))","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"As above, we can rewrite into an offset linear problem","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"W V^(i) = hat V^(i)","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"where","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"V^(i) = U^(i) + Omega^(i)","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"and","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"hat V^(i) \n  = hat U_(i) + (I - Delta t tilde a_ii L)  Omega^(i) \n  = u^n + Omega^(i) + Delta t sum_j=1^i-1 a_ij f(U^(j))","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"If using an iterative method, an initial guess is","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"bar V^(i) = bar U^(i) + Omega^(i)\n  = u^n + Delta t sum_j=1^i-1 a_ij f(U^(j)) \n  = hat V^(i) - Omega^(i)","category":"page"},{"location":"background/ark/#References","page":"Additive Runge–Kutta","title":"References","text":"","category":"section"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"F. X. Giraldo, J. F. Kelly, and E. M. Constantinescu (2013). Implicit-Explicit Formulations of a Three-Dimensional Nonhydrostatic Unified Model of the Atmosphere (NUMA) SIAM Journal on Scientific Computing 35(5), B1162-B1194, doi:10.1137/120876034","category":"page"},{"location":"callbacks/#Callbacks","page":"Callbacks","title":"Callbacks","text":"","category":"section"},{"location":"callbacks/","page":"Callbacks","title":"Callbacks","text":"CurrentModule = ClimaTimeSteppers.Callbacks","category":"page"},{"location":"callbacks/#Interfaces","page":"Callbacks","title":"Interfaces","text":"","category":"section"},{"location":"callbacks/","page":"Callbacks","title":"Callbacks","text":"initialize!\nfinalize!","category":"page"},{"location":"callbacks/#ClimaTimeSteppers.Callbacks.initialize!","page":"Callbacks","title":"ClimaTimeSteppers.Callbacks.initialize!","text":"ClimaTimeSteppers.Callbacks.initialize!(f!::F, integrator)\n\nInitialize a callback event for callbacks of type F. By default this does nothing, but can be extended for new callback events.\n\n\n\n\n\n","category":"function"},{"location":"callbacks/#ClimaTimeSteppers.Callbacks.finalize!","page":"Callbacks","title":"ClimaTimeSteppers.Callbacks.finalize!","text":"ClimaTimeSteppers.Callbacks.finalize!(f!::F, integrator)\n\nFinalize a callback event for callbacks of type F. By default this does nothing, but can be extended for new callback events.\n\n\n\n\n\n","category":"function"},{"location":"callbacks/#Callbacks-2","page":"Callbacks","title":"Callbacks","text":"","category":"section"},{"location":"callbacks/","page":"Callbacks","title":"Callbacks","text":"EveryXWallTimeSeconds\nEveryXSimulationTime\nEveryXSimulationSteps","category":"page"},{"location":"callbacks/#ClimaTimeSteppers.Callbacks.EveryXWallTimeSeconds","page":"Callbacks","title":"ClimaTimeSteppers.Callbacks.EveryXWallTimeSeconds","text":"EveryXWallTimeSeconds(f!, Δwt, comm_ctx::ClimaComms.AbstractCommsContext;\n                      atinit=false)\n\nTrigger f!(integrator) every Δwt wallclock seconds.\n\nAn ClimaComms context must be provided to synchronize timing across all ranks.\n\nCallbacks.initialize! and Callbacks.finalize! can be defined for f!.\n\nIf atinit=true, then f!(integrator) will additionally be triggered at initialization, otherwise the first trigger will be after Δwt seconds.\n\n\n\n\n\n","category":"function"},{"location":"callbacks/#ClimaTimeSteppers.Callbacks.EveryXSimulationTime","page":"Callbacks","title":"ClimaTimeSteppers.Callbacks.EveryXSimulationTime","text":"EveryXSimulationTime(f!, Δt;\n                     atinit=false)\n\nTrigger f!(integrator) every Δt simulation time.\n\nCallbacks.initialize! and Callbacks.finalize! can be defined for f!.\n\nIf atinit=true, then f! will additionally be triggered at initialization. Otherwise the first trigger will be after Δt simulation time.\n\n\n\n\n\n","category":"function"},{"location":"callbacks/#ClimaTimeSteppers.Callbacks.EveryXSimulationSteps","page":"Callbacks","title":"ClimaTimeSteppers.Callbacks.EveryXSimulationSteps","text":"EveryXSimulationSteps(f!, Δsteps;\n                     atinit=false)\n\nTrigger f!(integrator) every Δsteps simulation steps.\n\nCallbacks.initialize! and Callbacks.finalize! can be defined for f!.\n\nIf atinit==true, then f! will additionally be triggered at initialization. Otherwise the first trigger will be after Δsteps.\n\n\n\n\n\n","category":"function"},{"location":"#ClimaTimeSteppers.jl","page":"ClimaTimeSteppers.jl","title":"ClimaTimeSteppers.jl","text":"","category":"section"},{"location":"","page":"ClimaTimeSteppers.jl","title":"ClimaTimeSteppers.jl","text":"ClimaTimeSteppers.jl is a suite of ordinary differential equation (ODE) solvers for use as time-stepping methods in a partial differential equation (PDE) solver, such as ClimateMachine.jl. They are specifically written to support distributed and GPU computation, while minimising the memory footprint.","category":"page"},{"location":"","page":"ClimaTimeSteppers.jl","title":"ClimaTimeSteppers.jl","text":"ClimaTimeSteppers.jl is built on top of DiffEqBase.jl, and aims to be compatible with the DifferentialEquations.jl ecosystem.","category":"page"},{"location":"background/ssprk/#Strong-Stability-Preserving-Runge–Kutta-methods","page":"Strong Stability Preserving Runge–Kutta methods","title":"Strong Stability Preserving Runge–Kutta methods","text":"","category":"section"},{"location":"background/ssprk/","page":"Strong Stability Preserving Runge–Kutta methods","title":"Strong Stability Preserving Runge–Kutta methods","text":"SSPRK methods are self-starting, with U^(1) = u^n, and subsequent stage updates of the form","category":"page"},{"location":"background/ssprk/","page":"Strong Stability Preserving Runge–Kutta methods","title":"Strong Stability Preserving Runge–Kutta methods","text":"beginaligned\nU^(i+1) = A_i1 u^n + A_i2 U^(i) + Delta t B_i f(U^(i) t + c_i Delta t)\nendaligned","category":"page"},{"location":"background/ssprk/","page":"Strong Stability Preserving Runge–Kutta methods","title":"Strong Stability Preserving Runge–Kutta methods","text":"with the value at the next step being the N+1th stage value u^n+1 = U^(N+1)).","category":"page"},{"location":"background/ssprk/","page":"Strong Stability Preserving Runge–Kutta methods","title":"Strong Stability Preserving Runge–Kutta methods","text":"This allows the updates to be performed with only three copies of the state vector (storing u^n, U^(i) and f(U^(i)t)).","category":"page"},{"location":"algorithms/#Algorithms","page":"Algorithms","title":"Algorithms","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"CurrentModule = ClimaTimeSteppers","category":"page"},{"location":"algorithms/#IMEX-ARK-methods","page":"Algorithms","title":"IMEX ARK methods","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"IMEXARKAlgorithm","category":"page"},{"location":"algorithms/#ClimaTimeSteppers.IMEXARKAlgorithm","page":"Algorithms","title":"ClimaTimeSteppers.IMEXARKAlgorithm","text":"IMEXARKAlgorithm <: DistributedODEAlgorithm\n\nA generic implementation of an IMEX ARK algorithm that can handle arbitrary Butcher tableaus and problems specified using either ForwardEulerODEFunctions or regular ODEFunctions.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"The convergence orders of the provided methods are verified using test cases from ARKode. Plots of the solutions to these test cases, the errors of these solutions, and the convergence orders with respect to dt are shown below.","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"using Pkg\nPkg.activate(\"../../test\")\nPkg.instantiate()\ninclude(\"../../test/problems.jl\")\ninclude(\"../../test/utils.jl\")\ninclude(\"../../test/convergence.jl\")\nPkg.activate(\".\")","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"Plots for ark_analytic: (Image: ) (Image: ) (Image: )","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"Plots for ark_analytic_nonlin: (Image: ) (Image: ) (Image: )","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"Plots for ark_analytic_sys: (Image: ) (Image: ) (Image: )","category":"page"},{"location":"algorithms/#Low-Storage-Runge–Kutta-(LSRK)-methods","page":"Algorithms","title":"Low-Storage Runge–Kutta (LSRK) methods","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"Low-storage Runger–Kutta methods reduce the number stages that need to be stored. The methods below require only one additional storage vector.","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"An IncrementingODEProblem must be used.","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"LowStorageRungeKutta2N\nLSRK54CarpenterKennedy\nLSRK144NiegemannDiehlBusch\nLSRKEulerMethod","category":"page"},{"location":"algorithms/#ClimaTimeSteppers.LowStorageRungeKutta2N","page":"Algorithms","title":"ClimaTimeSteppers.LowStorageRungeKutta2N","text":"LowStorageRungeKutta2N <: DistributedODEAlgorithm\n\nA class of low-storage Runge-Kutta algorithms, which use only one additional copy of the state vector u (often referred to as 2N schemes).\n\nThe available implementations are:\n\nLSRKEulerMethod\nLSRK54CarpenterKennedy\nLSRK144NiegemannDiehlBusch\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#ClimaTimeSteppers.LSRK54CarpenterKennedy","page":"Algorithms","title":"ClimaTimeSteppers.LSRK54CarpenterKennedy","text":"LSRK54CarpenterKennedy()\n\nThe 4th-order, 5-stage [LowStorageRungeKutta2N])(ref) scheme from Solution 3 of Mark H Carpenter, Christopher A Kennedy (1994).\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#ClimaTimeSteppers.LSRK144NiegemannDiehlBusch","page":"Algorithms","title":"ClimaTimeSteppers.LSRK144NiegemannDiehlBusch","text":"LSRK144NiegemannDiehlBusch()\n\nThe 4th-order, 14-stage, [LowStorageRungeKutta2N])(ref) scheme of Jens Niegemann, Richard Diehl, Kurt Busch (2012) with optimized stability region\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#ClimaTimeSteppers.LSRKEulerMethod","page":"Algorithms","title":"ClimaTimeSteppers.LSRKEulerMethod","text":"LSRKEulerMethod()\n\nAn implementation of explicit Euler method using LowStorageRungeKutta2N infrastructure. This is mainly for debugging.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#Strong-Stability-Preserving-Runge–Kutta-(SSPRK)-methods","page":"Algorithms","title":"Strong Stability-Preserving Runge–Kutta (SSPRK) methods","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"StrongStabilityPreservingRungeKutta\nSSPRK22Heuns\nSSPRK22Ralstons\nSSPRK33ShuOsher\nSSPRK34SpiteriRuuth","category":"page"},{"location":"algorithms/#ClimaTimeSteppers.StrongStabilityPreservingRungeKutta","page":"Algorithms","title":"ClimaTimeSteppers.StrongStabilityPreservingRungeKutta","text":"StrongStabilityPreservingRungeKutta <: DistributedODEAlgorithm\n\nA class of Strong Stability Preserving Runge–Kutta methods. These require two additional copies of the state vector.\n\nThe available implementations are:\n\nSSPRK22Heuns\nSSPRK22Ralstons\nSSPRK33ShuOsher\nSSPRK34SpiteriRuuth\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#ClimaTimeSteppers.SSPRK22Heuns","page":"Algorithms","title":"ClimaTimeSteppers.SSPRK22Heuns","text":"SSPRK22Heuns()\n\nThe second-order, 2-stage, strong-stability-preserving, Runge–Kutta scheme of Chi-Wang Shu, Stanley Osher (1988), also known as Heun's method (Heun1900.\n\nExact choice of coefficients from wikipedia page for Heun's method :)\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#ClimaTimeSteppers.SSPRK22Ralstons","page":"Algorithms","title":"ClimaTimeSteppers.SSPRK22Ralstons","text":"SSPRK22Ralstons()\n\nThe second-order, 2-stage, strong-stability-preserving, Runge–Kutta scheme of Chi-Wang Shu, Stanley Osher (1988), also known as Ralstons's method (Anthony Ralston (1962).\n\nExact choice of coefficients from wikipedia page for Heun's method :)\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#ClimaTimeSteppers.SSPRK33ShuOsher","page":"Algorithms","title":"ClimaTimeSteppers.SSPRK33ShuOsher","text":"SSPRK33ShuOsher()\n\nThe third-order, 3-stage, strong-stability-preserving, Runge–Kutta scheme of Chi-Wang Shu, Stanley Osher (1988).\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#ClimaTimeSteppers.SSPRK34SpiteriRuuth","page":"Algorithms","title":"ClimaTimeSteppers.SSPRK34SpiteriRuuth","text":"SSPRK34SpiteriRuuth()\n\nThe third-order, 4-stage, strong-stability-preserving, Runge–Kutta scheme of Raymond J Spiteri, Steven J Ruuth (2002).\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#Additive-Runge–Kutta-(ARK)-methods","page":"Algorithms","title":"Additive Runge–Kutta (ARK) methods","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"ARK methods are IMEX (Implicit-Explicit) methods based on splitting the ODE function into a linear and remainder components:","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"fracdudt = Lu + f_R(ut)","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"where the linear part is solved implicitly. All the algorithms below take a linsolve argument to specify the linear solver to be used. See the linsolve specification of DifferentialEquations.jl.","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"Currently ARK methods require a SplitODEProblem.","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"AdditiveRungeKutta\nARK1ForwardBackwardEuler\nARK2ImplicitExplicitMidpoint\nARK2GiraldoKellyConstantinescu\nARK437L2SA1KennedyCarpenter\nARK548L2SA2KennedyCarpenter","category":"page"},{"location":"algorithms/#ClimaTimeSteppers.AdditiveRungeKutta","page":"Algorithms","title":"ClimaTimeSteppers.AdditiveRungeKutta","text":"AdditiveRungeKutta\n\nIMEX (IMplicit-EXplicit) algorithms using ARK (Additively-partitioned Runge-Kutta) methods.\n\nThe available implementations are:\n\nARK1ForwardBackwardEuler\nARK2ImplicitExplicitMidpoint\nARK2GiraldoKellyConstantinescu\nARK437L2SA1KennedyCarpenter\nARK548L2SA2KennedyCarpenter\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#ClimaTimeSteppers.ARK1ForwardBackwardEuler","page":"Algorithms","title":"ClimaTimeSteppers.ARK1ForwardBackwardEuler","text":"ARK1ForwardBackwardEuler(linsolve)\n\nA first-order-accurate two-stage additive Runge–Kutta scheme of Uri M. Ascher, Steven J. Ruuth, Raymond J. Spiteri (1997), combining a forward Euler explicit step with a backward Euler implicit correction.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#ClimaTimeSteppers.ARK2ImplicitExplicitMidpoint","page":"Algorithms","title":"ClimaTimeSteppers.ARK2ImplicitExplicitMidpoint","text":"ARK2ImplicitExplicitMidpoint(linsolve)\n\nA second-order, two-stage additive Runge–Kutta scheme Uri M. Ascher, Steven J. Ruuth, Raymond J. Spiteri (1997), combining the implicit and explicit midpoint methods.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#ClimaTimeSteppers.ARK2GiraldoKellyConstantinescu","page":"Algorithms","title":"ClimaTimeSteppers.ARK2GiraldoKellyConstantinescu","text":"ARK2GiraldoKellyConstantinescu(linsolve; paperversion=false)\n\nThe second-order, 3-stage additive Runge–Kutta scheme of GKC2013.\n\nIf the keyword paperversion=true is used, the coefficients from the paper are used. Otherwise it uses coefficients that make the scheme (much) more stable but less accurate\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#ClimaTimeSteppers.ARK437L2SA1KennedyCarpenter","page":"Algorithms","title":"ClimaTimeSteppers.ARK437L2SA1KennedyCarpenter","text":"ARK437L2SA1KennedyCarpenter(linsolve)\n\nThe fourth-order, 7-stage additive Runge–Kutta scheme ARK4(3)7L[2]SA₁ of Christopher A Kennedy, Mark H Carpenter (2019).\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#ClimaTimeSteppers.ARK548L2SA2KennedyCarpenter","page":"Algorithms","title":"ClimaTimeSteppers.ARK548L2SA2KennedyCarpenter","text":"ARK548L2SA2KennedyCarpenter(linsolve)\n\nThe fifth-order, 8-stage additive Runge–Kutta scheme ARK5(4)8L[2]SA₂ of Christopher A Kennedy, Mark H Carpenter (2019).\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#ARS","page":"Algorithms","title":"ARS","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"ARS111\nARS121\nARS343","category":"page"},{"location":"algorithms/#Multirate","page":"Algorithms","title":"Multirate","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"Multirate","category":"page"},{"location":"algorithms/#ClimaTimeSteppers.Multirate","page":"Algorithms","title":"ClimaTimeSteppers.Multirate","text":"Multirate(fast, slow)\n\nA multirate Runge–Kutta scheme, combining fast and slow algorithms\n\nslow can be any algorithm providing methods for the following functions\n\ninit_inner(prob, outercache, dt)\nupdate_inner!(innerinteg, outercache, f_slow, u, p, t, dt, stage)\n\nAlgorithms which currently support this are:\n\nLowStorageRungeKutta2N\nMultirateInfinitesimalStep\nWickerSkamarockRungeKutta\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#Multirate-Infinitesimal-Step","page":"Algorithms","title":"Multirate Infinitesimal Step","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"MultirateInfinitesimalStep\nMIS2\nMIS3C\nMIS4\nMIS4a\nTVDMISA\nTVDMISB","category":"page"},{"location":"algorithms/#ClimaTimeSteppers.MultirateInfinitesimalStep","page":"Algorithms","title":"ClimaTimeSteppers.MultirateInfinitesimalStep","text":"MultirateInfinitesimalStep\n\nMultirate Infinitesimal Step (MIS) methods of J{\\\"o}rg Wensch, Oswald Knoth, Alexander Galant (2009) and Oswald Knoth, Joerg Wensch (2014).\n\nThe available implementations are:\n\nMIS2\nMIS3C\nMIS4\nMIS4a\nTVDMISA\nTVDMISB\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#ClimaTimeSteppers.MIS2","page":"Algorithms","title":"ClimaTimeSteppers.MIS2","text":"MIS2()\n\nThe MIS2 Multirate Infinitesimal Step (MIS) method of Oswald Knoth, Joerg Wensch (2014).\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#ClimaTimeSteppers.MIS3C","page":"Algorithms","title":"ClimaTimeSteppers.MIS3C","text":"MIS3C()\n\nThe MIS3C Multirate Infinitesimal Step (MIS) method of Oswald Knoth, Joerg Wensch (2014).\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#ClimaTimeSteppers.MIS4","page":"Algorithms","title":"ClimaTimeSteppers.MIS4","text":"MIS4()\n\nThe MIS4 Multirate Infinitesimal Step (MIS) method of Oswald Knoth, Joerg Wensch (2014).\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#ClimaTimeSteppers.MIS4a","page":"Algorithms","title":"ClimaTimeSteppers.MIS4a","text":"MIS4a()\n\nThe MIS4a Multirate Infinitesimal Step (MIS) method of Oswald Knoth, Joerg Wensch (2014).\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#ClimaTimeSteppers.TVDMISA","page":"Algorithms","title":"ClimaTimeSteppers.TVDMISA","text":"TVDMISA()\n\nThe TVDMISA Total Variation Diminishing (TVD) Multirate Infinitesimal Step (MIS) method of Oswald Knoth, Joerg Wensch (2014).\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#ClimaTimeSteppers.TVDMISB","page":"Algorithms","title":"ClimaTimeSteppers.TVDMISB","text":"TVDMISB()\n\nThe TVDMISB Total Variation Diminishing (TVD) Multirate Infinitesimal Step (MIS) method of Oswald Knoth, Joerg Wensch (2014).\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#Wicker–Skamarock","page":"Algorithms","title":"Wicker–Skamarock","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"WickerSkamarockRungeKutta\nWSRK2\nWSRK3","category":"page"},{"location":"algorithms/#ClimaTimeSteppers.WickerSkamarockRungeKutta","page":"Algorithms","title":"ClimaTimeSteppers.WickerSkamarockRungeKutta","text":"WickerSkamarockRungeKutta <: DistributedODEAlgorithm\n\nClass of multirate algorithms developed in Louis J Wicker, William C Skamarock (1998) and Louis J Wicker, William C Skamarock (2002), which can be used as slow methods in Multirate.\n\nThese require two additional copies of the state vector u.\n\nAvailable implementations are:\n\nWSRK2\nWSRK3\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#ClimaTimeSteppers.WSRK2","page":"Algorithms","title":"ClimaTimeSteppers.WSRK2","text":"WSRK2()\n\nThe 2 stage, 2nd order RK2 scheme of Louis J Wicker, William C Skamarock (1998).\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#ClimaTimeSteppers.WSRK3","page":"Algorithms","title":"ClimaTimeSteppers.WSRK3","text":"WSRK3()\n\nThe 3 stage, 2nd order (3rd order for linear problems) RK3 scheme of Louis J Wicker, William C Skamarock (2002).\n\n\n\n\n\n","category":"type"}]
}
