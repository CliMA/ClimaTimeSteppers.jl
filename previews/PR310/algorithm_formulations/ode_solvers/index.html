<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>ODE Solvers · ClimaTimeSteppers</title><meta name="title" content="ODE Solvers · ClimaTimeSteppers"/><meta property="og:title" content="ODE Solvers · ClimaTimeSteppers"/><meta property="twitter:title" content="ODE Solvers · ClimaTimeSteppers"/><meta name="description" content="Documentation for ClimaTimeSteppers."/><meta property="og:description" content="Documentation for ClimaTimeSteppers."/><meta property="twitter:description" content="Documentation for ClimaTimeSteppers."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ClimaTimeSteppers</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">ClimaTimeSteppers.jl</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2"><span class="docs-label">Algorithm Formulations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>ODE Solvers</a><ul class="internal"><li><a class="tocitem" href="#Standard-IMEX-ARK"><span>Standard IMEX ARK</span></a></li><li><a class="tocitem" href="#Adding-DSS"><span>Adding DSS</span></a></li><li><a class="tocitem" href="#Adding-a-Limiter"><span>Adding a Limiter</span></a></li><li><a class="tocitem" href="#Summary"><span>Summary</span></a></li><li><a class="tocitem" href="#Running-Newton&#39;s-Method"><span>Running Newton&#39;s Method</span></a></li></ul></li><li><a class="tocitem" href="../newtons_method/">Newtons Method</a></li><li><a class="tocitem" href="../rosenbrock/">Rosenbrock Method</a></li><li><a class="tocitem" href="../lsrk/">Old LSRK Formulations</a></li><li><a class="tocitem" href="../mrrk/">Old MRRK Formulations</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Test problems</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../test_problems/">Test problems</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/diffusion/">A full example on how to use ClimaTimesteppers with ClimaCore</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">API docs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/ode_solvers/">ODE Solvers</a></li><li><a class="tocitem" href="../../api/newtons_method/">Newtons Method</a></li><li><a class="tocitem" href="../../api/callbacks/">Callbacks</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Developer docs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../dev/types/">Types</a></li><li><a class="tocitem" href="../../dev/report_gen/">Report generator</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Algorithm Formulations</a></li><li class="is-active"><a href>ODE Solvers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>ODE Solvers</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/CliMA/ClimaTimeSteppers.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/CliMA/ClimaTimeSteppers.jl/blob/main/docs/src/algorithm_formulations/ode_solvers.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="ODE-Solvers"><a class="docs-heading-anchor" href="#ODE-Solvers">ODE Solvers</a><a id="ODE-Solvers-1"></a><a class="docs-heading-anchor-permalink" href="#ODE-Solvers" title="Permalink"></a></h1><h2 id="Standard-IMEX-ARK"><a class="docs-heading-anchor" href="#Standard-IMEX-ARK">Standard IMEX ARK</a><a id="Standard-IMEX-ARK-1"></a><a class="docs-heading-anchor-permalink" href="#Standard-IMEX-ARK" title="Permalink"></a></h2><p>An <em>ordinary differential equation</em> (ODE) is an equation of the form</p><p class="math-container">\[\frac{d}{dt}u(t) = T(u(t), t),\]</p><p>where <span>$u(t)$</span> is called the <em>state</em> at time <span>$t$</span>, and <span>$T(u(t), t)$</span> is called the <em>tendency</em> of the state at time <span>$t$</span>.</p><p>The simplest method for numerically solving this equation with a finite <em>timestep</em> <span>$\Delta t$</span> is the <em>forward Euler</em> method, in which the equation is approximated as</p><p class="math-container">\[\frac{u(t + \Delta t) - u(t)}{\Delta t} \approx T(u(t), t).\]</p><p>Given the value of <span>$u_0 = u(t_0)$</span> at some time <span>$t_0$</span>, the approximation implies that <span>$u(t_0 + \Delta t) \approx \hat{u}$</span>, where</p><p class="math-container">\[\hat{u} = u_0 + \Delta t T(u_0, t_0).\]</p><p>An alternative approximation is given by the <em>backward Euler</em> method:</p><p class="math-container">\[\frac{u(t + \Delta t) - u(t)}{\Delta t} \approx T(u(t + \Delta t), t + \Delta t).\]</p><p>With this approximation, <span>$u(t_0 + \Delta t) \approx \hat{u}$</span>, where <span>$\hat{u}$</span> is now the solution to the equation</p><p class="math-container">\[u_0 + \Delta t T(\hat{u}, t_0 + \Delta t) - \hat{u} = 0.\]</p><p>Unlike the forward Euler method, in which <span>$\hat{u}$</span> is directly computed based on the known state <span>$u_0$</span>, the backward Euler method involves solving a root equation in order to obtain the value of <span>$\hat{u}$</span>. So, the forward Euler method is called an <em>explicit</em> method, whereas the backward Euler method is called an <em>implicit</em> method.</p><p>In general, <span>$T$</span> can be a complicated nonlinear function of <span>$u(t)$</span> and <span>$t$</span>, and it is usually not possible to solve the backward Euler method&#39;s implicit equation for <span>$\hat{u}$</span> analytically. Instead, it is often necessary to use an iterative root-finding algorithm like Newton&#39;s method to solve for <span>$\hat{u}$</span>. Although this is more computationally expensive than using the forward Euler method to directly obtain <span>$\hat{u}$</span> from <span>$u_0$</span>, it is often necessary to deal with the problem of <em>stiffness</em>.</p><p>Roughly speaking, a tendency <span>$T$</span> is stiff when the forward Euler method requires a relatively small timestep <span>$\Delta t$</span> to obtain a reasonably accurate solution, where &quot;relatively small&quot; means that it is smaller than one would expect based on the rate at which <span>$u(t)$</span> changes over time. When <span>$T$</span> is not stiff, a small timestep is only required when <span>$u(t)$</span> changes quickly with respect to <span>$t$</span>, and a larger timestep can be used when <span>$u(t)$</span> changes slowly. The backward Euler method is more <em>stable</em> than the forward Euler method, which means that it is usually able to take larger timesteps, especially when <span>$T$</span> is stiff.</p><p>As a compromise between the simplicity of the forward Euler method and the stability of the backward Euler method, it is common to use the <em>implicit-explicit</em> (IMEX) Euler method. This involves splitting <span>$T$</span> into an explicit tendency <span>$T_{\text{exp}}$</span> and an implicit tendency <span>$T_{\text{imp}}$</span>, so that <span>$T(u(t), t) = T_{\text{exp}}(u(t), t) + T_{\text{imp}}(u(t), t)$</span>, and making the approximation</p><p class="math-container">\[\frac{u(t + \Delta t) - u(t)}{\Delta t} \approx T_{\text{exp}}(u(t), t) + T_{\text{imp}}(u(t + \Delta t), t + \Delta t).\]</p><p>With this approximation, the implicit equation for <span>$\hat{u}$</span> becomes</p><p class="math-container">\[u_0 + \Delta t T_{\text{exp}}(u_0, t_0) + \Delta t T_{\text{imp}}(\hat{u}, t_0 + \Delta t) - \hat{u} = 0.\]</p><p>Note that <span>$T_{\text{exp}}$</span> is evaluated explicitly at the known state <span>$u_0$</span>, while <span>$T_{\text{imp}}$</span> is evaluated implicitly at the unknown state <span>$\hat{u}$</span>.</p><p>Both the forward and backward Euler methods (and, by extension, the IMEX Euler method) are <em>first-order</em> methods, which means that the errors of their approximations are proportional to <span>$\Delta t$</span> when <span>$\Delta t$</span> is sufficiently close to 0.<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup> In order to achieve a reasonable accuracy with fewer timesteps, it is common to use <em>higher-order</em> methods, where a method of order <span>$p$</span> will have an error that is proportional to <span>$(\Delta t)^p$</span> for small values of <span>$\Delta t$</span>. The simplest higher-order generalization of the forward and backward Euler methods is a <em>Runge-Kutta</em> method, in which there are <span>$s$</span> <em>stages</em> <span>$U_1, U_2, \ldots, U_s$</span> that satisfy</p><p class="math-container">\[U_i = u_0 + \Delta t \sum_{j = 1}^s a_{i,j} T(U_j, t_0 + \Delta t c_j),\]</p><p>and <span>$u(t_0 + \Delta t)$</span> is approximated as</p><p class="math-container">\[\hat{u} = u_0 + \Delta t \sum_{i = 1}^s b_i T(U_i, t_0 + \Delta t c_i).\]</p><p>The coefficients <span>$a_{i,j}$</span>, <span>$b_i$</span>, and <span>$c_i$</span> of a Runge-Kutta method can be summarized in a <em>Butcher tableau</em>:</p><p class="math-container">\[\begin{array}{c|c c c c c} c_1 &amp; a_{1,1} &amp; a_{1,2} &amp; \cdots &amp; a_{1,s - 1} &amp; a_{1,s} \\ c_2 &amp; a_{2,1} &amp; a_{2,2} &amp; \cdots &amp; a_{2,s - 1} &amp; a_{2,s} \\ c_3 &amp; a_{3,1} &amp; a_{3,2} &amp; \cdots &amp; a_{3,s - 1} &amp; a_{3,s} \\ \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots \\ c_s &amp; a_{s,1} &amp; a_{s,2} &amp; \cdots &amp; a_{s,s - 1} &amp; a_{s,s} \\ \hline &amp; b_1 &amp; b_2 &amp; \cdots &amp; b_{s - 1} &amp; b_s \end{array}\]</p><p>Since solving a system of <span>$s$</span> coupled equations for the stages <span>$U_i$</span> is usually impractical, many of the <span>$a_{i,j}$</span> coefficients are set to 0 in commonly used Runge-Kutta methods. When <span>$a_{i,j} = 0$</span> for all <span>$j \geq i$</span>, the equation for <span>$U_i$</span> simplifies to the explicit formula</p><p class="math-container">\[U_i = u_0 + \Delta t \sum_{j = 1}^{i - 1} a_{i,j} T(U_j, t_0 + \Delta t c_j).\]</p><p>This is called an explicit Runge-Kutta (ERK) method. When <span>$a_{i,j} = 0$</span> for all <span>$j &gt; i$</span>, the implicit equation for <span>$U_i$</span> becomes uncoupled from the equations for the other stages, and it can be rewritten as</p><p class="math-container">\[u_0 + \Delta t \sum_{j = 1}^{i - 1} a_{i,j} T(U_j, t_0 + \Delta t c_j) + \Delta t a_{i,i} T(U_i, t_0 + \Delta t c_i) - U_i = 0.\]</p><p>Since the only unknown tendency in this equation comes from the diagonal coefficient <span>$a_{i,i}$</span>, this is called a <em>diagonally implicit</em> Runge-Kutta (DIRK) method. There are many different categories of DIRK methods, such as <em>explicit first stage</em> DIRK (EDIRK), where <span>$a_{1,1} = 0$</span>, <em>singly</em> DIRK (SDIRK), where <span>$a_{1,1} = a_{2,2} = \ldots = a_{s,s} = \gamma$</span> for some constant <span>$\gamma$</span>, and ESDIRK, where <span>$a_{1,1} = 0$</span> and <span>$a_{2,2} = \ldots = a_{s,s} = \gamma$</span>.</p><p>Just as the forward and backward Euler methods can be combined into the IMEX Euler method, two Runge-Kutta methods can be combined into an <em>additive</em> Runge-Kutta (ARK) method. If the first method is explicit and the second is implicit, the result is an IMEX ARK method. We will only be considering IMEX ARK methods where the implicit part is DIRK. If the DIRK method has coefficients <span>$a_{i,j}$</span>, <span>$b_i$</span>, and <span>$c_i$</span>, and the ERK method has coefficients <span>$\tilde{a}_{i,j}$</span>, <span>$\tilde{b}_i$</span>, and <span>$\tilde{c}_i$</span>, the IMEX ARK method approximates <span>$u(t_0 + \Delta t)$</span> as</p><p class="math-container">\[\hat{u} = u_0 + \Delta t \sum_{i = 1}^s \left(\tilde{b}_i T_{\text{exp}}(U_i, t_0 + \Delta t \tilde{c}_i) + b_i T_{\text{imp}}(U_i, t_0 + \Delta t c_i)\right),\]</p><p>where the implicit equation for <span>$U_i$</span> is now</p><p class="math-container">\[u_0 + \Delta t \sum_{j = 1}^{i - 1} \left(\tilde{a}_{i,j} T_{\text{exp}}(U_j, t_0 + \Delta t \tilde{c}_j) + a_{i,j} T_{\text{imp}}(U_j, t_0 + \Delta t c_j)\right) + \Delta t a_{i,i} T_{\text{imp}}(U_i, t_0 + \Delta t c_i) - U_i = 0.\]</p><h2 id="Adding-DSS"><a class="docs-heading-anchor" href="#Adding-DSS">Adding DSS</a><a id="Adding-DSS-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-DSS" title="Permalink"></a></h2><p>It is often necessary to filter the state so that it satisfies some particular constraint before it is used to evaluate a tendency. In our case, the state is a collection of values defined across a spatially discretized domain. When we use a <em>continuous Galerkin</em> (CG) spectral element discretization, we must ensure that the state is continuous across element boundaries before we use it to compute any tendency. We can turn any state that is discontinuous across element boundaries into a continuous one by applying a <em>direct stiffness summation</em> (DSS) to it. Applying DSS to <span>$\hat{u}$</span> in the IMEX ARK method is straightforward:</p><p class="math-container">\[\hat{u} = \textrm{DSS}\left(u_0 + \Delta t \sum_{i = 1}^s \left(\tilde{b}_i T_{\text{exp}}(U_i, t_0 + \Delta t \tilde{c}_i) + b_i T_{\text{imp}}(U_i, t_0 + \Delta t c_i)\right)\right).\]</p><p>Applying DSS to each stage <span>$U_i$</span> is a bit trickier. Ideally, we would use the equation</p><p class="math-container">\[\textrm{DSS}\left(\begin{aligned} &amp; u_0 + \Delta t \sum_{j = 1}^{i - 1} \left(\tilde{a}_{i,j} T_{\text{exp}}(U_j, t_0 + \Delta t \tilde{c}_j) + a_{i,j} T_{\text{imp}}(U_j, t_0 + \Delta t c_j)\right) + \\ &amp; \Delta t a_{i,i} T_{\text{imp}}(U_i, t_0 + \Delta t c_i) \end{aligned}\right) - U_i = 0,\]</p><p>since this would ensure that the implicit tendency <span>$T_{\text{imp}}$</span> gets evaluated at a continuous stage <span>$U_i$</span>. However, this equation is more challenging to solve than the original one, since it involves applying DSS, which is usually a more complicated function than <span>$T_{\text{imp}}$</span>, to an unknown quantity. So, we instead use the equation</p><p class="math-container">\[\begin{aligned} \textrm{DSS}\left(u_0 + \Delta t \sum_{j = 1}^{i - 1} \left(\tilde{a}_{i,j} T_{\text{exp}}(U_j, t_0 + \Delta t \tilde{c}_j) + a_{i,j} T_{\text{imp}}(U_j, t_0 + \Delta t c_j)\right)\right) + &amp; \\ \Delta t a_{i,i} T_{\text{imp}}(U_i, t_0 + \Delta t c_i) - U_i &amp;= 0. \end{aligned}\]</p><p>This equation is identical to the previous one only when <span>$T_{\text{imp}}$</span> preserves the effects of DSS. That is to say, if evaluating <span>$T_{\text{imp}}$</span> at a continuous stage <span>$U_i$</span> produces a continuous tendency, then it is not necessary to apply DSS after adding this tendency to a continuous quantity. This also assumes that the root-finding algorithm used to compute <span>$U_i$</span> preserves the effects of DSS, which will usually be the case as long as <span>$T_{\text{imp}}$</span> does so. In general, one could replace DSS with a filter that enforces some other constraint, as long as that constraint is preserved by <span>$T_{\text{imp}}$</span>. The constraint must also be preserved by addition and by multiplication with a constant, which are the only other operations used to compute <span>$U_i$</span> after applying the filter.</p><p>Note that this method of enforcing a constraint is not mathematically rigorous, as it does not necessarily maintain the convergence properties of the IMEX ARK method. This is because DSS effectively acts like a tendency on each stage <span>$U_i$</span>, but, unlike the actual tendencies <span>$T_{\text{exp}}$</span> and <span>$T_{\text{imp}}$</span>, the effects of DSS on the previous stages <span>$U_1, U_2, \ldots, U_{i - 1}$</span> are not accounted for when computing <span>$U_i$</span>. The proper way to enforce a constraint would be to extend the ODE to a <em>differential-algebraic equation</em> (DAE) by adding an algebraic equation <span>$F(u(t), t) = 0$</span> that can only be satisfied when <span>$u(t)$</span> obeys the constraint, and then solving the DAE using an appropriate numerical method. However, this route would be significantly more computationally expensive than our method. Moreover, we have observed that the effects of DSS are sufficiently small to not noticeably disrupt the convergence of IMEX ARK methods in our test cases, though this will not necessarily be the case if DSS is replaced with another filter.</p><h2 id="Adding-a-Limiter"><a class="docs-heading-anchor" href="#Adding-a-Limiter">Adding a Limiter</a><a id="Adding-a-Limiter-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-a-Limiter" title="Permalink"></a></h2><p>In addition to filtering the state, it is often necessary to filter part of the tendency, but in a way that depends on the state to which the tendency is being added. In our case, because we use a spectral element discretization, part of the explicit tendency can add spurious oscillations to each stage. We can limit these oscillations by using a <em>monotonicity-preserving limiter</em> (see [<a href="../../references/#GTS2014">1</a>]), which is a function <span>$\textrm{lim}_{u(t)}$</span> that, when used with an appropriate tendency <span>$T_{\text{lim}}(u(t), t)$</span> and a sufficiently small constant <span>$C$</span>, satisfies the inequalities</p><p class="math-container">\[\begin{aligned} \textrm{min}\biggl(\textrm{lim}_{u(t)}\bigl(u(t) + C T_{\text{lim}}(u(t), t)\bigr)\biggr) &amp;\geq \textrm{min}\bigl(u(t)\bigr) \text{ and} \\ \textrm{max}\biggl(\textrm{lim}_{u(t)}\bigl(u(t) + C T_{\text{lim}}(u(t), t)\bigr)\biggr) &amp;\leq \textrm{max}\bigl(u(t)\bigr). \end{aligned}\]</p><p>In other words, applying the limiter to a state incremented by the limited tendency, <span>$u(t) + C T_{\text{lim}}(u(t), t)$</span>, ensures that the extrema of the incremented state do not exceed the extrema of the unincremented state, <span>$u(t)$</span>. Note that the process of incrementing a state in this way is used by the forward Euler method with <span>$\Delta t = C$</span> and <span>$T = T_{\text{lim}}$</span>, which is why it is called an <em>Euler step</em>. Since spurious oscillations usually cause the extrema of the state to grow, this is an effective mechanism for eliminating such oscillations. Note that the limiter can only preserve monotonicity by comparing the incremented state to the unincremented state, which means that the effects of the limiter are a function of the unincremented state (hence the subscript in <span>$\textrm{lim}_{u(t)}$</span>).</p><p>Unfortunately, there is no mathematically correct way to incorporate the use of a limiter into a general IMEX ARK method. The most straightforward approach is to split <span>$T_{\text{exp}}$</span> into two tendencies <span>$T_{\text{exp}}$</span> and <span>$T_{\text{lim}}$</span>, to modify the equation for <span>$\hat{u}$</span> to</p><p class="math-container">\[\begin{aligned} \hat{u} ={} &amp; \textrm{lim}_{u_0}\left(u_0 + \Delta t \sum_{i = 1}^s \tilde{b}_i T_{\text{lim}}(U_i, t_0 + \Delta t \tilde{c}_i)\right) + \\ &amp; \Delta t \sum_{i = 1}^s \left(\tilde{b}_i T_{\text{exp}}(U_i, t_0 + \Delta t \tilde{c}_i) + b_i T_{\text{imp}}(U_i, t_0 + \Delta t c_i)\right), \end{aligned}\]</p><p>and to modify the equation for <span>$U_i$</span> to</p><p class="math-container">\[\begin{aligned} \textrm{lim}_{u_0}\left(u_0 + \Delta t \sum_{j = 1}^{i - 1} \tilde{a}_{i,j} T_{\text{lim}}(U_j, t_0 + \Delta t \tilde{c}_j)\right) + &amp; \\ \Delta t \sum_{j = 1}^{i - 1} \left(\tilde{a}_{i,j} T_{\text{exp}}(U_j, t_0 + \Delta t \tilde{c}_j) + a_{i,j} T_{\text{imp}}(U_j, t_0 + \Delta t c_j)\right) + &amp; \\ \Delta t a_{i,i} T_{\text{imp}}(U_i, t_0 + \Delta t c_i) - U_i &amp;= 0. \end{aligned}\]</p><p>Not only does this approach not maintain the convergence properties of the IMEX ARK method (for the same reason as DSS above),<sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup> but it also does not even use the limiter in a way that allows it to preserve monotonicity. That is, the argument of <span>$\textrm{lim}_{u_0}$</span> does not have the form needed to satisfy the min and max constraints given above, since it involves evaluating the limited tendency at states that are not the unincremented state. As luck would have it, we have observed that the limiter, even when used in such an incorrect manner, is still able to substantially reduce spurious oscillations in our test cases, though it is not able to perform as well as it would if it were used correctly.</p><p>In order to use the limiter &quot;more correctly&quot;, we constrain the ERK Butcher tableau coefficients to have the following form:</p><p class="math-container">\[\begin{array}{c|c c c c c} \tilde{c}_1 &amp; 0 &amp; 0 &amp; \cdots &amp; 0 &amp; 0 \\ \tilde{c}_2 &amp; \beta_1 &amp; 0 &amp; \cdots &amp; 0 &amp; 0 \\ \tilde{c}_3 &amp; \beta_1 \beta_2 &amp; \beta_2 &amp; \cdots &amp; 0 &amp; 0 \\ \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots \\ \tilde{c}_s &amp; \beta_1 \beta_2 \ldots \beta_{s - 1} &amp; \beta_2 \ldots \beta_{s - 1} &amp; \cdots &amp; \beta_{s - 1} &amp; 0 \\ \hline &amp; \beta_1 \beta_2 \ldots \beta_{s - 1} \beta_s &amp; \beta_2 \ldots \beta_{s - 1} \beta_s &amp; \cdots &amp; \beta_{s - 1} \beta_s &amp; \beta_s \end{array}\]</p><p>If all of the coefficients <span>$\beta_1, \beta_2, \ldots, \beta_s$</span> are nonnegative, and if the resulting ERK method converges, it is called a <em>strong stability preserving</em> Runge-Kutta (SSPRK) method.<sup class="footnote-reference"><a id="citeref-3" href="#footnote-3">[3]</a></sup> Moreover, if the ERK method is SSPRK, then the overall IMEX ARK method is called an IMEX SSPRK method.</p><p>Now, in order to simplify our notation, we will define <span>$s + 1$</span> values <span>$\tilde{U}_1, \tilde{U}_2, \ldots, \tilde{U}_{s + 1}$</span>, where</p><p class="math-container">\[\tilde{U}_i = \begin{cases} \displaystyle u_0 + \Delta t \sum_{j = 1}^{i - 1} \tilde{a}_{i,j} T_{\text{exp}}(U_j, t_0 + \Delta t \tilde{c}_j) &amp; i &lt; s + 1 \\ \displaystyle u_0 + \Delta t \sum_{i = 1}^s \tilde{b}_i T_{\text{exp}}(U_i, t_0 + \Delta t \tilde{c}_i) &amp; i = s + 1 \end{cases}.\]</p><p>This allows us to rewrite the IMEX ARK equation for <span>$\hat{u}$</span> as</p><p class="math-container">\[\hat{u} = \tilde{U}_{s + 1} + \Delta t \sum_{i = 1}^s b_i T_{\text{imp}}(U_i, t_0 + \Delta t c_i),\]</p><p>and to rewrite the equation for <span>$U_i$</span> as</p><p class="math-container">\[\tilde{U}_i + \Delta t \sum_{j = 1}^{i - 1} a_{i,j} T_{\text{imp}}(U_j, t_0 + \Delta t c_j) + \Delta t a_{i,i} T_{\text{imp}}(U_i, t_0 + \Delta t c_i) - U_i = 0.\]</p><p>If we constrain the IMEX ARK method to an IMEX SSPRK method, we can express <span>$\tilde{b}_i$</span> as</p><p class="math-container">\[\tilde{b}_i = \begin{cases} \beta_s \tilde{a}_{s,i} &amp; i &lt; s \\ \beta_s &amp; i = s \end{cases},\]</p><p>which means that</p><p class="math-container">\[\begin{aligned} \tilde{U}_{s + 1} ={} &amp; u_0 + \Delta t \sum_{i = 1}^{s - 1} \tilde{b}_i T_{\text{exp}}(U_i, t_0 + \Delta t \tilde{c}_i) + \Delta t \tilde{b}_s T_{\text{exp}}(U_s, t_0 + \Delta t \tilde{c}_s) = \\ &amp; u_0 + \Delta t \beta_s \sum_{i = 1}^{s - 1} \tilde{a}_{s,i} T_{\text{exp}}(U_i, t_0 + \Delta t \tilde{c}_i) + \Delta t \beta_s T_{\text{exp}}(U_s, t_0 + \Delta t \tilde{c}_s) = \\ &amp; (1 - \beta_s) u_0 + \beta_s \left(\tilde{U}_s + \Delta t T_{\text{exp}}(U_s, t_0 + \Delta t \tilde{c}_s)\right). \end{aligned}\]</p><p>In addition, for all <span>$i &gt; 1$</span>,</p><p class="math-container">\[\tilde{a}_{i,j} = \begin{cases} \beta_{i - 1} \tilde{a}_{i - 1,j} &amp; j &lt; i - 1 \\ \beta_{i - 1} &amp; j = i - 1 \end{cases},\]</p><p>which means that</p><p class="math-container">\[\begin{aligned} \tilde{U}_i ={} &amp; u_0 + \Delta t \sum_{j = 1}^{i - 2} \tilde{a}_{i,j} T_{\text{exp}}(U_j, t_0 + \Delta t \tilde{c}_j) + \Delta t \tilde{a}_{i,i - 1} T_{\text{exp}}(U_{i - 1}, t_0 + \Delta t \tilde{c}_{i - 1}) = \\ &amp; u_0 + \Delta t \beta_{i - 1} \sum_{j = 1}^{i - 2} \tilde{a}_{i - 1,j} T_{\text{exp}}(U_j, t_0 + \Delta t \tilde{c}_j) + \Delta t \beta_{i - 1} T_{\text{exp}}(U_{i - 1}, t_0 + \Delta t \tilde{c}_{i - 1}) = \\ &amp; (1 - \beta_{i - 1}) u_0 + \beta_{i - 1} \left(\tilde{U}_{i - 1} + \Delta t T_{\text{exp}}(U_{i - 1}, t_0 + \Delta t \tilde{c}_{i - 1})\right). \end{aligned}\]</p><p>Since <span>$\tilde{U}_1 = u_0$</span>, constraining the IMEX ARK method to an IMEX SSPRK method allows us to express <span>$\tilde{U}_i$</span> as</p><p class="math-container">\[\tilde{U}_i = \begin{cases} u_0 &amp; i = 1 \\ (1 - \beta_{i - 1}) u_0 + \beta_{i - 1} \left(\tilde{U}_{i - 1} + \Delta t T_{\text{exp}}(U_{i - 1}, t_0 + \Delta t \tilde{c}_{i - 1})\right) &amp; i &gt; 1 \end{cases}.\]</p><p>To incorporate the use of a limiter into the IMEX SSPRK method, we split <span>$T_{\text{exp}}$</span> into <span>$T_{\text{exp}}$</span> and <span>$T_{\text{lim}}$</span>, and we modify the equation for <span>$\tilde{U}_i$</span> to</p><p class="math-container">\[\tilde{U}_i = \begin{cases} u_0 &amp; i = 1 \\ \begin{aligned} &amp; (1 - \beta_{i - 1}) u_0 +{} \\ &amp; \quad\beta_{i - 1} \left(\textrm{lim}_{\tilde{U}_{i - 1}}\left(\tilde{U}_{i - 1} + \Delta t T_{\text{lim}}(U_{i - 1}, t_0 + \Delta t \tilde{c}_{i - 1})\right) + \Delta t T_{\text{exp}}(U_{i - 1}, t_0 + \Delta t \tilde{c}_{i - 1})\right) \end{aligned} &amp; i &gt; 1 \end{cases}.\]</p><p>In this equation, the limiter is being applied to a limited tendency evaluated at <span>$U_{i - 1}$</span>, but with <span>$\tilde{U}_{i - 1}$</span> as the unincremented state. If there is no implicit tendency, so that <span>$T_{\text{imp}}$</span> is always 0, then <span>$U_{i - 1} = \tilde{U}_{i - 1}$</span>, and the limiter is able to properly preserve monotonicity. On the other hand, if there is an implicit tendency, then the limiter will not necessarily preserve monotonicity. That is, the limiter is guaranteed to function properly when the limited tendency is used in a sequence of Euler steps.</p><h2 id="Summary"><a class="docs-heading-anchor" href="#Summary">Summary</a><a id="Summary-1"></a><a class="docs-heading-anchor-permalink" href="#Summary" title="Permalink"></a></h2><p>We will now summarize our IMEX methods when using both DSS and a limiter.</p><h4 id="IMEX-ARK"><a class="docs-heading-anchor" href="#IMEX-ARK">IMEX ARK</a><a id="IMEX-ARK-1"></a><a class="docs-heading-anchor-permalink" href="#IMEX-ARK" title="Permalink"></a></h4><p>Our general IMEX ARK method is defined by two Butcher tableaus:</p><p class="math-container">\[\begin{array}{c|c c c c c} \tilde{c}_1 &amp; 0 &amp; 0 &amp; \cdots &amp; 0 &amp; 0 \\ \tilde{c}_2 &amp; \tilde{a}_{2,1} &amp; 0 &amp; \cdots &amp; 0 &amp; 0 \\ \tilde{c}_3 &amp; \tilde{a}_{3,1} &amp; \tilde{a}_{3,2} &amp; \cdots &amp; 0 &amp; 0 \\ \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots \\ \tilde{c}_s &amp; \tilde{a}_{s,1} &amp; \tilde{a}_{s,2} &amp; \cdots &amp; \tilde{a}_{s,s - 1} &amp; 0 \\ \hline &amp; \tilde{b}_1 &amp; \tilde{b}_2 &amp; \cdots &amp; \tilde{b}_{s - 1} &amp; \tilde{b}_s \end{array} \text{ and } \begin{array}{c|c c c c c} c_1 &amp; a_{1,1} &amp; 0 &amp; \cdots &amp; 0 &amp; 0 \\ c_2 &amp; a_{2,1} &amp; a_{2,2} &amp; \cdots &amp; 0 &amp; 0 \\ c_3 &amp; a_{3,1} &amp; a_{3,2} &amp; \cdots &amp; 0 &amp; 0 \\ \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots \\ c_s &amp; a_{s,1} &amp; a_{s,2} &amp; \cdots &amp; a_{s,s - 1} &amp; a_{s,s} \\ \hline &amp; b_1 &amp; b_2 &amp; \cdots &amp; b_{s - 1} &amp; b_s \end{array}\]</p><p>Given <span>$u_0 = u(t_0)$</span>, it approximates the value of <span>$u(t_0 + \Delta t)$</span> as</p><p class="math-container">\[\hat{u} = \textrm{DSS}\left(\begin{aligned} &amp; \textrm{lim}_{u_0}\left(u_0 + \Delta t \sum_{i = 1}^s \tilde{b}_i T_{\text{lim}}(U_i, t_0 + \Delta t \tilde{c}_i)\right) + \\ &amp; \Delta t \sum_{i = 1}^s \left(\tilde{b}_i T_{\text{exp}}(U_i, t_0 + \Delta t \tilde{c}_i) + b_i T_{\text{imp}}(U_i, t_0 + \Delta t c_i)\right) \end{aligned}\right),\]</p><p>where <span>$U_i$</span> is the solution to the equation</p><p class="math-container">\[\textrm{DSS}\left(\begin{aligned} &amp; \textrm{lim}_{u_0}\left(u_0 + \Delta t \sum_{j = 1}^{i - 1} \tilde{a}_{i,j} T_{\text{lim}}(U_j, t_0 + \Delta t \tilde{c}_j)\right) + \\ &amp; \Delta t \sum_{j = 1}^{i - 1} \left(\tilde{a}_{i,j} T_{\text{exp}}(U_j, t_0 + \Delta t \tilde{c}_j) + a_{i,j} T_{\text{imp}}(U_j, t_0 + \Delta t c_j)\right) \end{aligned}\right) + \Delta t a_{i,i} T_{\text{imp}}(U_i, t_0 + \Delta t c_i) - U_i = 0.\]</p><h4 id="IMEX-SSPRK"><a class="docs-heading-anchor" href="#IMEX-SSPRK">IMEX SSPRK</a><a id="IMEX-SSPRK-1"></a><a class="docs-heading-anchor-permalink" href="#IMEX-SSPRK" title="Permalink"></a></h4><p>Our IMEX SSPRK method is defined by two Butcher tableaus:</p><p class="math-container">\[\begin{array}{c|c c c c c} \tilde{c}_1 &amp; 0 &amp; 0 &amp; \cdots &amp; 0 &amp; 0 \\ \tilde{c}_2 &amp; \beta_1 &amp; 0 &amp; \cdots &amp; 0 &amp; 0 \\ \tilde{c}_3 &amp; \beta_1 \beta_2 &amp; \beta_2 &amp; \cdots &amp; 0 &amp; 0 \\ \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots \\ \tilde{c}_s &amp; \beta_1 \beta_2 \ldots \beta_{s - 1} &amp; \beta_2 \ldots \beta_{s - 1} &amp; \cdots &amp; \beta_{s - 1} &amp; 0 \\ \hline &amp; \beta_1 \beta_2 \ldots \beta_{s - 1} \beta_s &amp; \beta_2 \ldots \beta_{s - 1} \beta_s &amp; \cdots &amp; \beta_{s - 1} \beta_s &amp; \beta_s \end{array} \text{ and } \begin{array}{c|c c c c c} c_1 &amp; a_{1,1} &amp; 0 &amp; \cdots &amp; 0 &amp; 0 \\ c_2 &amp; a_{2,1} &amp; a_{2,2} &amp; \cdots &amp; 0 &amp; 0 \\ c_3 &amp; a_{3,1} &amp; a_{3,2} &amp; \cdots &amp; 0 &amp; 0 \\ \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots \\ c_s &amp; a_{s,1} &amp; a_{s,2} &amp; \cdots &amp; a_{s,s - 1} &amp; a_{s,s} \\ \hline &amp; b_1 &amp; b_2 &amp; \cdots &amp; b_{s - 1} &amp; b_s \end{array}\]</p><p>Given <span>$u_0 = u(t_0)$</span>, it approximates the value of <span>$u(t_0 + \Delta t)$</span> as</p><p class="math-container">\[\hat{u} = \textrm{DSS}\left(\tilde{U}_{s + 1} + \Delta t \sum_{i = 1}^s b_i T_{\text{imp}}(U_i, t_0 + \Delta t c_i)\right),\]</p><p>where <span>$U_i$</span> is the solution to the equation</p><p class="math-container">\[\textrm{DSS}\left(\tilde{U}_i + \Delta t \sum_{j = 1}^{i - 1} a_{i,j} T_{\text{imp}}(U_j, t_0 + \Delta t c_j)\right) + \Delta t a_{i,i} T_{\text{imp}}(U_i, t_0 + \Delta t c_i) - U_i = 0,\]</p><p>and where</p><p class="math-container">\[\tilde{U}_i = \begin{cases} u_0 &amp; i = 1 \\ \begin{aligned} &amp; (1 - \beta_{i - 1}) u_0 +{} \\ &amp; \quad\beta_{i - 1} \left(\textrm{lim}_{\tilde{U}_{i - 1}}\left(\tilde{U}_{i - 1} + \Delta t T_{\text{lim}}(U_{i - 1}, t_0 + \Delta t \tilde{c}_{i - 1})\right) + \Delta t T_{\text{exp}}(U_{i - 1}, t_0 + \Delta t \tilde{c}_{i - 1})\right) \end{aligned} &amp; i &gt; 1 \end{cases}.\]</p><h2 id="Running-Newton&#39;s-Method"><a class="docs-heading-anchor" href="#Running-Newton&#39;s-Method">Running Newton&#39;s Method</a><a id="Running-Newton&#39;s-Method-1"></a><a class="docs-heading-anchor-permalink" href="#Running-Newton&#39;s-Method" title="Permalink"></a></h2><p>Every implicit equation for <span>$U_i$</span> has the form <span>$f_i(U_i) = 0$</span>, where</p><p class="math-container">\[f_i(x) = R_i + \Delta t a_{i,i} T_{\text{imp}}(x, t_0 + \Delta t c_i) - x.\]</p><p>In this function, <span>$R_i$</span>, <span>$\Delta t a_{i,i}$</span>, and <span>$t_0 + \Delta t c_i$</span> are all quantities that do not depend on <span>$x$</span>. The Jacobian of this function is</p><p class="math-container">\[W_i(x) = \frac{d}{dx}f_i(x) = \Delta t a_{i,i} J_{\text{imp}}(x, t_0 + \Delta t c_i) - 1,\]</p><p>where <span>$J_{\text{imp}}$</span> is the Jacobian of the implicit tendency,</p><p class="math-container">\[J_{\text{imp}}(x, t) = \frac{\partial}{\partial x}T_{\text{imp}}(x, t).\]</p><p>The value of <span>$U_i$</span> can be computed by running Newton&#39;s method with <span>$f = f_i$</span> and <span>$j = W_i$</span>.</p><p>Note that &quot;<span>$W$</span>&quot; is used to denote the same quantity in <a href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/v6.0.0/src/derivative_utils.jl">OrdinaryDiffEq.jl</a>.</p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a><br/>More precisely, the <em>local truncation error</em> of the forward and backward Euler methods after a single timestep is <span>$O\left((\Delta t)^2\right)$</span>, which means that <span>$|u(t_0 + \Delta t) - \hat{u}| &lt; C (\Delta t)^2$</span> for all <span>$\Delta t &lt; D$</span>, where <span>$C$</span> and <span>$D$</span> are some constants. On the other hand, the <em>global truncation error</em> after taking enough timesteps to go from <span>$t_0$</span> to some <span>$t_1 &gt; t_0$</span> is <span>$O(\Delta t)$</span>. This is because there are <span>$(t_1 - t_0) / \Delta t$</span> timesteps between <span>$t_0$</span> and <span>$t_1$</span>, and, if each timestep has a local truncation error of <span>$O\left((\Delta t)^2\right)$</span>, then the error after <span>$O\left((\Delta t)^{-1}\right)$</span> timesteps must be <span>$O(\Delta t)$</span>. In general, for a Runge-Kutta method (or ARK method) of order <span>$p$</span>, the local truncation error is <span>$O\left((\Delta t)^{p + 1}\right)$</span>, and the global truncation error is <span>$O\left((\Delta t)^{p\vphantom{1}}\right)$</span>.</li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a><br/>By <a href="https://en.wikipedia.org/wiki/Godunov%27s_theorem">Godunov&#39;s theorem</a>, no monotonicity-preserving linear numerical method can have an order greater than 1. Since <span>$\textrm{lim}_{u_0}$</span> will usually be a nonlinear function, this is not a linear numerical method. However, it is a rough approximation of the unmodified ARK method, so it is likely that Godunov&#39;s theorem will still apply; i.e., we do not expect to observe an order greater than 1 when using a limiter.</li><li class="footnote" id="footnote-3"><a class="tag is-link" href="#citeref-3">3</a><br/>This is really a <em>low-storage</em> SSPRK method that only requires two registers for storing states, using one of the registers to store <span>$u_0$</span>; this is an example of a <span>$2N^*$</span> method (see [<a href="../../references/#HR2018arxiv">2</a>]). A general SSPRK method has just as many independent coefficients as a general ERK method, though its coefficients are used somewhat differently, in a way that makes them more amenable to limiters. We restrict ourselves to <span>$s$</span> independent coefficients <span>$\beta_i$</span> merely for the sake of simplicity. In the future, we might want to generalize to arbitrary SSPRK methods.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« ClimaTimeSteppers.jl</a><a class="docs-footer-nextpage" href="../newtons_method/">Newtons Method »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Thursday 12 September 2024 19:23">Thursday 12 September 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
