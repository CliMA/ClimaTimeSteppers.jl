var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"background/lsrk/#Low-storage-Runge–Kutta-methods","page":"Low-storage Runge–Kutta methods","title":"Low-storage Runge–Kutta methods","text":"","category":"section"},{"location":"background/lsrk/","page":"Low-storage Runge–Kutta methods","title":"Low-storage Runge–Kutta methods","text":"LSRK methods are self-starting, with U^(1) = u^n, and then using stage updates of the form","category":"page"},{"location":"background/lsrk/","page":"Low-storage Runge–Kutta methods","title":"Low-storage Runge–Kutta methods","text":"beginaligned\ndU^(i) = f(U^(i) t + c_i Delta t) + A_i dU^(i-1)\nU^(i+1) = U^(i) + Delta t B_i dU^(i)\nendaligned","category":"page"},{"location":"background/lsrk/","page":"Low-storage Runge–Kutta methods","title":"Low-storage Runge–Kutta methods","text":"where A_1 = c_1 = 0 (implying dU^(1) = f(u^n t)), with the value at the next step being the N+1th stage value u^n+1 = U^(N+1)).","category":"page"},{"location":"background/lsrk/","page":"Low-storage Runge–Kutta methods","title":"Low-storage Runge–Kutta methods","text":"This allows the updates to be performed with only two copies of the state vector (so long as f can be evaluated in incrementing form).","category":"page"},{"location":"background/lsrk/","page":"Low-storage Runge–Kutta methods","title":"Low-storage Runge–Kutta methods","text":"It can be written as an RK scheme with Butcher tableau coefficients defined by the recurrences","category":"page"},{"location":"background/lsrk/","page":"Low-storage Runge–Kutta methods","title":"Low-storage Runge–Kutta methods","text":"beginaligned\na_ii = 0 \na_ij = B_j + A_j+1 a_ij+1\nb_N = B_N \nb_i = B_i + A_i+1 b_i+1\nendaligned","category":"page"},{"location":"background/lsrk/","page":"Low-storage Runge–Kutta methods","title":"Low-storage Runge–Kutta methods","text":"or equivalently","category":"page"},{"location":"background/lsrk/","page":"Low-storage Runge–Kutta methods","title":"Low-storage Runge–Kutta methods","text":"beginaligned\na_jj = 0 \na_ij = a_i-1j + B_i-1 prod_k=j+1^i-1 A_k\nendaligned","category":"page"},{"location":"background/lsrk/","page":"Low-storage Runge–Kutta methods","title":"Low-storage Runge–Kutta methods","text":"with b_j treated analogously as a_N+1j.","category":"page"},{"location":"background/mrrk/#Multirate-Runge-Kutta","page":"Multirate Runge Kutta","title":"Multirate Runge Kutta","text":"","category":"section"},{"location":"background/mrrk/","page":"Multirate Runge Kutta","title":"Multirate Runge Kutta","text":"Given a problem with two components that operate at two rates:","category":"page"},{"location":"background/mrrk/","page":"Multirate Runge Kutta","title":"Multirate Runge Kutta","text":"fracdudt = f_F(ut) + f_S(ut)","category":"page"},{"location":"background/mrrk/","page":"Multirate Runge Kutta","title":"Multirate Runge Kutta","text":"where f_F is the fast component, and f_S is the slow component.","category":"page"},{"location":"background/mrrk/","page":"Multirate Runge Kutta","title":"Multirate Runge Kutta","text":"M. Schlegel , O. Knoth , M. Arnold , R. Wolke  (2012) defines the following method.","category":"page"},{"location":"background/mrrk/","page":"Multirate Runge Kutta","title":"Multirate Runge Kutta","text":"Given an outer explicit Runge–Kutta scheme with tableau (abc)","category":"page"},{"location":"background/mrrk/","page":"Multirate Runge Kutta","title":"Multirate Runge Kutta","text":"We can define the stage values U^(i) = v_i(tau_i) as the solution to the inner ODE problem","category":"page"},{"location":"background/mrrk/","page":"Multirate Runge Kutta","title":"Multirate Runge Kutta","text":"fracdv_idtau\n  = sum_j=1^i  fraca_ij - a_i-1jc_i - c_i-1  f_S (U^(j) tau_j)\n    + f_F(v_i tau)\nquad tau in tau_i-1 tau","category":"page"},{"location":"background/mrrk/","page":"Multirate Runge Kutta","title":"Multirate Runge Kutta","text":"where tau_i = t + Delta t c_i, with initial condition v_i(tau_i-1) = U^(i-1). If c_i == c_i-1, we can treat it as a correction step:","category":"page"},{"location":"background/mrrk/","page":"Multirate Runge Kutta","title":"Multirate Runge Kutta","text":"U^(i) = U^(i-1) + Delta t fracsum_j=1^i (a_ij - a_i-1j)c_i - c_i-1 f_S (U^(j) tau_i)","category":"page"},{"location":"background/mrrk/","page":"Multirate Runge Kutta","title":"Multirate Runge Kutta","text":"The final summation stage treating analogously to i=N+1, with a_N+1j = b_j and c_N+1 = 1.","category":"page"},{"location":"background/mrrk/#Low-storage","page":"Multirate Runge Kutta","title":"Low-storage","text":"","category":"section"},{"location":"background/mrrk/","page":"Multirate Runge Kutta","title":"Multirate Runge Kutta","text":"If using a low-storage Runge–Kutta method is used as an outer solver, then this reduces to","category":"page"},{"location":"background/mrrk/","page":"Multirate Runge Kutta","title":"Multirate Runge Kutta","text":"fracdv_idtau\n  =  fracB_i-1c_i - c_i-1 dU_S^(i-1)\n    + f_F(v_i tau)\nquad tau in tau_i-1 tau","category":"page"},{"location":"background/mrrk/","page":"Multirate Runge Kutta","title":"Multirate Runge Kutta","text":"where","category":"page"},{"location":"background/mrrk/","page":"Multirate Runge Kutta","title":"Multirate Runge Kutta","text":"dU_S^(i) = f_S(U^(i) tau_i) + A_i dU_S^(i-1)","category":"page"},{"location":"background/mrrk/#Multirate-Infinitesimal-Step-(MIS)","page":"Multirate Runge Kutta","title":"Multirate Infinitesimal Step (MIS)","text":"","category":"section"},{"location":"background/mrrk/","page":"Multirate Runge Kutta","title":"Multirate Runge Kutta","text":"Multirate Infinitesimal Step (MIS) methods (J { \\ \" o } rg Wensch , Oswald Knoth , Alexander Galant  (2009), Oswald Knoth , Joerg Wensch  (2014))","category":"page"},{"location":"background/mrrk/","page":"Multirate Runge Kutta","title":"Multirate Runge Kutta","text":"beginaligned\nv_i (0)\n  = u^n + sum_j=1^i-1 alpha_ij (U^(j) - u^n)\n\nfracdv_idtau\n  = sum_j=1^i-1 fracgamma_ijd_i Delta t (U^(j) - u^n)\n    + sum_j=1^i fracbeta_ijd_i f_S (U^(j) t + Delta t c_i)\n    + f_F(v_i t^n +  Delta t tilde c_i + fracc_i - tilde c_id_i tau)\nquad tau in 0 Delta t d_i\n\nU^(i) = v_i(Delta t d_i)\nendaligned","category":"page"},{"location":"background/mrrk/","page":"Multirate Runge Kutta","title":"Multirate Runge Kutta","text":"The method is defined in terms of the lower-triangular matrices alpha, beta and gamma, with d_i = sum_j beta_ij, c_i = (I - alpha - gamma)^-1 d and tilde c = alpha c.","category":"page"},{"location":"background/mrrk/#Wicker-Skamarock","page":"Multirate Runge Kutta","title":"Wicker Skamarock","text":"","category":"section"},{"location":"background/mrrk/","page":"Multirate Runge Kutta","title":"Multirate Runge Kutta","text":"Louis J Wicker , William C Skamarock  (1998) and Louis J Wicker , William C Skamarock  (2002) define RK2 and RK3 multirate schemes:","category":"page"},{"location":"background/mrrk/","page":"Multirate Runge Kutta","title":"Multirate Runge Kutta","text":"beginaligned\nv_i (t) = u^n\n\nfracdv_idtau\n  = f_S (U^(i-1) t + Delta t c_i-1)\n    + f_F(v_i tau)\nquad tau in t t+ Delta t c_i \n\nU^(i) = v_i(t + Delta t c_i)\nendaligned","category":"page"},{"location":"background/mrrk/","page":"Multirate Runge Kutta","title":"Multirate Runge Kutta","text":"which corresponds to an MIS method with alpha = gamma = 0 and beta = operatornamediag(c).","category":"page"},{"location":"background/ark/#Additive-Runge–Kutta","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"","category":"section"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"ARK methods are IMEX (Implicit-Explicit) methods based on splitting the ODE function f(u) = f_L(u) + f_R(t)  where f_L(u) = L u is a linear operator which is treated implicitly, and f_R(u) is the remainder to be treated explicitly. Typically we will be given either the pair (f_R f_L), which we will term the remainder form, or (f f_L) which we will term the full form. ","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"The value on the ith stage U^(i) is","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"U^(i) = u^n + Delta t sum_j=1^i tilde a_ij f_L(U^(j)) \n              + Delta t sum_j=1^i-1 a_ij f_R(U^(j))","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"which can be written as the solution to the linear problem:","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"W U^(i) = hat U^(i)","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"where","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"hat U^(i) = u^n + Delta t sum_j=1^i-1 tilde a_ij f_L(U^(j)) \n                                             + Delta t sum_j=1^i-1 a_ij f_R(U^(j))","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"and","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"W = (I - Delta t tilde a_ii L)","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"The next step is then defined as","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"u^n+1 = u^n + Delta t sum_i=1^N b_i  f_L(U^(i)) + f_R(U^(i)) ","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"When an iterative solver is used, an initial value bar U^(i) can be chosen by an explicit approximation","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"bar U^(i) = u^n + Delta t sum_j=1^i-1 a_ij  f_L(U^(j)) + f_R(U^(j)) \n            = hat U^(i) + Delta t sum_j=1^i-1 (a_ij - tilde a_ij)  f_L(U^(j)) ","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"By convention, tilde a_11 = 0, so that U^(1) = u^n, and for all other stages the implicit coefficients tilde a_ii are the same. ","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"If the linear operator L is time-invariant and Delta t is constantm, then if using a direct solver, W only needs to be factorized once.","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"Alternatively if an iterative solver is used used, we can write","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"bar U^(i) = u^n + Delta t sum_j=1^i-1 a_ij  f_L(U^(j)) + f_R(U^(j)) \n            = hat U^(i) + Delta t  L sum_j=1^i-1 (a_ij - tilde a_ij)  U^(j)","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"at the cost of one evaluation of f_L.","category":"page"},{"location":"background/ark/#Reducing-evaluations-and-storage","page":"Additive Runge–Kutta","title":"Reducing evaluations and storage","text":"","category":"section"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"If the linear operator L is constant, then we are able to avoid evaluating the f_L explicitly.","category":"page"},{"location":"background/ark/#Remainder-form","page":"Additive Runge–Kutta","title":"Remainder form","text":"","category":"section"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"If we are given f_L and f_R, we can avoid storing f_L(U^(j)) by further defining","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"Omega^(i) = sum_j=1^i-1 fractilde a_ijtilde a_ii U^(j)","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"and writing","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"hat U^(i) = u^n + Delta t tilde a_ii f_L( Omega^(i) ) + Delta t sum_j=1^i-1 a_ij f_R(U^(j))","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"This can be rewritten into an offset linear problem","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"W V^(i) = hat V^(i)","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"where","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"V^(i) = U^(i) + Omega^(i)","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"and","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"hat V^(i)\n  = hat U_(i) + (I - Delta t tilde a_ii L)  Omega^(i) \n  = u^n + Omega^(i) + Delta t sum_j=1^i-1 a_ij f_R(U^(j))","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"If using an iterative method, an initial guess is","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"bar V^(i) = bar U^(i) + Omega^(i)\n  = u^n + Delta t sum_j=1^i-1 a_ij f_R(U^(j)) + Omega^(i) + Delta t sum_j=1^i-1 a_ij f_L(U^(j))\n  = hat V^(i) + Delta t L sum_j=1^i-1 a_ij U^(j)","category":"page"},{"location":"background/ark/#Full-form","page":"Additive Runge–Kutta","title":"Full form","text":"","category":"section"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"Similary, if we are given f and f_L, we can avoid storing f_L(U^(j)) by defining","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"Omega^(i) = sum_j=1^i-1 fractilde a_ij - a_ijtilde a_ii U^(j)","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"so that we can write","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"hat U^(i) = u^n + Delta t tilde a_ii f_L(Omega^(i)) + Delta t sum_j=1^i-1 a_ij f(U^(j))","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"As above, we can rewrite into an offset linear problem","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"W V^(i) = hat V^(i)","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"where","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"V^(i) = U^(i) + Omega^(i)","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"and","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"hat V^(i) \n  = hat U_(i) + (I - Delta t tilde a_ii L)  Omega^(i) \n  = u^n + Omega^(i) + Delta t sum_j=1^i-1 a_ij f(U^(j))","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"If using an iterative method, an initial guess is","category":"page"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"bar V^(i) = bar U^(i) + Omega^(i)\n  = u^n + Delta t sum_j=1^i-1 a_ij f(U^(j)) \n  = hat V^(i) - Omega^(i)","category":"page"},{"location":"background/ark/#References","page":"Additive Runge–Kutta","title":"References","text":"","category":"section"},{"location":"background/ark/","page":"Additive Runge–Kutta","title":"Additive Runge–Kutta","text":"F. X. Giraldo, J. F. Kelly, and E. M. Constantinescu (2013). Implicit-Explicit Formulations of a Three-Dimensional Nonhydrostatic Unified Model of the Atmosphere (NUMA) SIAM Journal on Scientific Computing 35(5), B1162-B1194, doi:10.1137/120876034","category":"page"},{"location":"callbacks/#Callbacks","page":"Callbacks","title":"Callbacks","text":"","category":"section"},{"location":"callbacks/","page":"Callbacks","title":"Callbacks","text":"CurrentModule = TimeMachine.Callbacks","category":"page"},{"location":"callbacks/#Interfaces","page":"Callbacks","title":"Interfaces","text":"","category":"section"},{"location":"callbacks/","page":"Callbacks","title":"Callbacks","text":"initialize!\nfinalize!","category":"page"},{"location":"callbacks/#TimeMachine.Callbacks.initialize!","page":"Callbacks","title":"TimeMachine.Callbacks.initialize!","text":"TimeMachine.Callbacks.initialize!(f!::F, integrator)\n\nInitialize a callback event for callbacks of type F. By default this does nothing, but can be extended for new callback events.\n\n\n\n\n\n","category":"function"},{"location":"callbacks/#TimeMachine.Callbacks.finalize!","page":"Callbacks","title":"TimeMachine.Callbacks.finalize!","text":"TimeMachine.Callbacks.finalize!(f!::F, integrator)\n\nFinalize a callback event for callbacks of type F. By default this does nothing, but can be extended for new callback events.\n\n\n\n\n\n","category":"function"},{"location":"callbacks/#Callbacks-2","page":"Callbacks","title":"Callbacks","text":"","category":"section"},{"location":"callbacks/","page":"Callbacks","title":"Callbacks","text":"EveryXWallTimeSeconds\nEveryXSimulationTime\nEveryXSimulationSteps","category":"page"},{"location":"callbacks/#TimeMachine.Callbacks.EveryXWallTimeSeconds","page":"Callbacks","title":"TimeMachine.Callbacks.EveryXWallTimeSeconds","text":"EveryXWallTimeSeconds(f!, Δwt, comm::MPI.Comm; \n                      atinit=false)\n\nTrigger f!(integrator) every Δwt wallclock seconds.\n\nAn MPI communicator comm must be provided to synchronize timing across all ranks.\n\nCallbacks.initialize! and Callbacks.finalize! can be defined for f!.\n\nIf atinit=true, then f!(integrator) will additionally be triggered at initialization, otherwise the first trigger will be after Δwt seconds.\n\n\n\n\n\n","category":"function"},{"location":"callbacks/#TimeMachine.Callbacks.EveryXSimulationTime","page":"Callbacks","title":"TimeMachine.Callbacks.EveryXSimulationTime","text":"EveryXSimulationTime(f!, Δt;\n                     atinit=false)\n\nTrigger f!(integrator) every Δt simulation time.\n\nCallbacks.initialize! and Callbacks.finalize! can be defined for f!.\n\nIf atinit=true, then f! will additionally be triggered at initialization. Otherwise the first trigger will be after Δt simulation time.\n\n\n\n\n\n","category":"function"},{"location":"callbacks/#TimeMachine.Callbacks.EveryXSimulationSteps","page":"Callbacks","title":"TimeMachine.Callbacks.EveryXSimulationSteps","text":"EveryXSimulationSteps(f!, Δsteps;\n                     atinit=false)\n\nTrigger f!(integrator) every Δsteps simulation steps.\n\nCallbacks.initialize! and Callbacks.finalize! can be defined for f!.\n\nIf atinit==true, then f! will additionally be triggered at initialization. Otherwise the first trigger will be after Δsteps.\n\n\n\n\n\n","category":"function"},{"location":"#TimeMachine.jl","page":"TimeMachine.jl","title":"TimeMachine.jl","text":"","category":"section"},{"location":"","page":"TimeMachine.jl","title":"TimeMachine.jl","text":"TimeMachine.jl is a suite of ordinary differential equation (ODE) solvers for use as time-stepping methods in a partial differential equation (PDE) solver, such as ClimateMachine.jl. They are specifically written to support distributed and GPU computation, while minimising the memory footprint.","category":"page"},{"location":"","page":"TimeMachine.jl","title":"TimeMachine.jl","text":"TimeMachine.jl is built on top of DiffEqBase.jl, and aims to be compatible with the DifferentialEquations.jl ecosystem.","category":"page"},{"location":"background/ssprk/#Strong-Stability-Preserving-Runge–Kutta-methods","page":"Strong Stability Preserving Runge–Kutta methods","title":"Strong Stability Preserving Runge–Kutta methods","text":"","category":"section"},{"location":"background/ssprk/","page":"Strong Stability Preserving Runge–Kutta methods","title":"Strong Stability Preserving Runge–Kutta methods","text":"SSPRK methods are self-starting, with U^(1) = u^n, and subsequent stage updates of the form","category":"page"},{"location":"background/ssprk/","page":"Strong Stability Preserving Runge–Kutta methods","title":"Strong Stability Preserving Runge–Kutta methods","text":"beginaligned\nU^(i+1) = A_i1 u^n + A_i2 U^(i) + Delta t B_i f(U^(i) t + c_i Delta t)\nendaligned","category":"page"},{"location":"background/ssprk/","page":"Strong Stability Preserving Runge–Kutta methods","title":"Strong Stability Preserving Runge–Kutta methods","text":"with the value at the next step being the N+1th stage value u^n+1 = U^(N+1)).","category":"page"},{"location":"background/ssprk/","page":"Strong Stability Preserving Runge–Kutta methods","title":"Strong Stability Preserving Runge–Kutta methods","text":"This allows the updates to be performed with only three copies of the state vector (storing u^n, U^(i) and f(U^(i)t)).","category":"page"},{"location":"algorithms/#Algorithms","page":"Algorithms","title":"Algorithms","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"CurrentModule = TimeMachine","category":"page"},{"location":"algorithms/#Low-Storage-Runge–Kutta-(LSRK)-methods","page":"Algorithms","title":"Low-Storage Runge–Kutta (LSRK) methods","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"Low-storage Runger–Kutta methods reduce the number stages that need to be stored. The methods below require only one additional storage vector.","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"An IncrementingODEProblem must be used.","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"LowStorageRungeKutta2N\nLSRK54CarpenterKennedy\nLSRK144NiegemannDiehlBusch\nLSRKEulerMethod","category":"page"},{"location":"algorithms/#TimeMachine.LowStorageRungeKutta2N","page":"Algorithms","title":"TimeMachine.LowStorageRungeKutta2N","text":"LowStorageRungeKutta2N <: DistributedODEAlgorithm\n\nA class of low-storage Runge-Kutta algorithms, which use only one additional copy of the state vector u (often referred to as 2N schemes).\n\nThe available implementations are:\n\nLSRKEulerMethod\nLSRK54CarpenterKennedy\nLSRK144NiegemannDiehlBusch\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#TimeMachine.LSRK54CarpenterKennedy","page":"Algorithms","title":"TimeMachine.LSRK54CarpenterKennedy","text":"LSRK54CarpenterKennedy()\n\nThe 4th-order, 5-stage [LowStorageRungeKutta2N])(ref) scheme from Solution 3 of Mark H Carpenter , Christopher A Kennedy  (1994).\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#TimeMachine.LSRK144NiegemannDiehlBusch","page":"Algorithms","title":"TimeMachine.LSRK144NiegemannDiehlBusch","text":"LSRK144NiegemannDiehlBusch()\n\nThe 4th-order, 14-stage, [LowStorageRungeKutta2N])(ref) scheme of Jens Niegemann , Richard Diehl , Kurt Busch  (2012) with optimized stability region\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#TimeMachine.LSRKEulerMethod","page":"Algorithms","title":"TimeMachine.LSRKEulerMethod","text":"LSRKEulerMethod()\n\nAn implementation of explicit Euler method using LowStorageRungeKutta2N infrastructure. This is mainly for debugging.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#Strong-Stability-Preserving-Runge–Kutta-(SSPRK)-methods","page":"Algorithms","title":"Strong Stability-Preserving Runge–Kutta (SSPRK) methods","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"StrongStabilityPreservingRungeKutta\nSSPRK22Heuns\nSSPRK22Ralstons\nSSPRK33ShuOsher\nSSPRK34SpiteriRuuth","category":"page"},{"location":"algorithms/#TimeMachine.StrongStabilityPreservingRungeKutta","page":"Algorithms","title":"TimeMachine.StrongStabilityPreservingRungeKutta","text":"StrongStabilityPreservingRungeKutta <: DistributedODEAlgorithm\n\nA class of Strong Stability Preserving Runge–Kutta methods. These require two additional copies of the state vector.\n\nThe available implementations are:\n\nSSPRK22Heuns\nSSPRK22Ralstons\nSSPRK33ShuOsher\nSSPRK34SpiteriRuuth\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#TimeMachine.SSPRK22Heuns","page":"Algorithms","title":"TimeMachine.SSPRK22Heuns","text":"SSPRK22Heuns()\n\nThe second-order, 2-stage, strong-stability-preserving, Runge–Kutta scheme of Chi-Wang Shu , Stanley Osher  (1988), also known as Heun's method (Heun1900.\n\nExact choice of coefficients from wikipedia page for Heun's method :)\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#TimeMachine.SSPRK22Ralstons","page":"Algorithms","title":"TimeMachine.SSPRK22Ralstons","text":"SSPRK22Ralstons()\n\nThe second-order, 2-stage, strong-stability-preserving, Runge–Kutta scheme of Chi-Wang Shu , Stanley Osher  (1988), also known as Ralstons's method (Anthony Ralston  (1962).\n\nExact choice of coefficients from wikipedia page for Heun's method :)\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#TimeMachine.SSPRK33ShuOsher","page":"Algorithms","title":"TimeMachine.SSPRK33ShuOsher","text":"SSPRK33ShuOsher()\n\nThe third-order, 3-stage, strong-stability-preserving, Runge–Kutta scheme of Chi-Wang Shu , Stanley Osher  (1988).\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#TimeMachine.SSPRK34SpiteriRuuth","page":"Algorithms","title":"TimeMachine.SSPRK34SpiteriRuuth","text":"SSPRK34SpiteriRuuth()\n\nThe third-order, 4-stage, strong-stability-preserving, Runge–Kutta scheme of Raymond J Spiteri , Steven J Ruuth  (2002).\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#Additive-Runge–Kutta-(ARK)-methods","page":"Algorithms","title":"Additive Runge–Kutta (ARK) methods","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"ARK methods are IMEX (Implicit-Explicit) methods based on splitting the ODE function into a linear and remainder components:","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"fracdudt = Lu + f_R(ut)","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"where the linear part is solved implicitly. All the algorithms below take a linsolve argument to specify the linear solver to be used. See the linsolve specification of DifferentialEquations.jl.","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"Currently ARK methods require a SplitODEProblem.","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"AdditiveRungeKutta\nARK1ForwardBackwardEuler\nARK2ImplicitExplicitMidpoint\nARK2GiraldoKellyConstantinescu\nARK437L2SA1KennedyCarpenter\nARK548L2SA2KennedyCarpenter","category":"page"},{"location":"algorithms/#TimeMachine.AdditiveRungeKutta","page":"Algorithms","title":"TimeMachine.AdditiveRungeKutta","text":"AdditiveRungeKutta\n\nIMEX (IMplicit-EXplicit) algorithms using ARK (Additively-partitioned Runge-Kutta) methods.\n\nThe available implementations are:\n\nARK1ForwardBackwardEuler\nARK2ImplicitExplicitMidpoint\nARK2GiraldoKellyConstantinescu\nARK437L2SA1KennedyCarpenter\nARK548L2SA2KennedyCarpenter\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#TimeMachine.ARK1ForwardBackwardEuler","page":"Algorithms","title":"TimeMachine.ARK1ForwardBackwardEuler","text":"ARK1ForwardBackwardEuler(linsolve)\n\nA first-order-accurate two-stage additive Runge–Kutta scheme of Uri M. Ascher , Steven J. Ruuth , Raymond J. Spiteri  (1997), combining a forward Euler explicit step with a backward Euler implicit correction.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#TimeMachine.ARK2ImplicitExplicitMidpoint","page":"Algorithms","title":"TimeMachine.ARK2ImplicitExplicitMidpoint","text":"ARK2ImplicitExplicitMidpoint(linsolve)\n\nA second-order, two-stage additive Runge–Kutta scheme Uri M. Ascher , Steven J. Ruuth , Raymond J. Spiteri  (1997), combining the implicit and explicit midpoint methods.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#TimeMachine.ARK2GiraldoKellyConstantinescu","page":"Algorithms","title":"TimeMachine.ARK2GiraldoKellyConstantinescu","text":"ARK2GiraldoKellyConstantinescu(linsolve; paperversion=false)\n\nThe second-order, 3-stage additive Runge–Kutta scheme of GKC2013.\n\nIf the keyword paperversion=true is used, the coefficients from the paper are used. Otherwise it uses coefficients that make the scheme (much) more stable but less accurate\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#TimeMachine.ARK437L2SA1KennedyCarpenter","page":"Algorithms","title":"TimeMachine.ARK437L2SA1KennedyCarpenter","text":"ARK437L2SA1KennedyCarpenter(linsolve)\n\nThe fourth-order, 7-stage additive Runge–Kutta scheme ARK4(3)7L[2]SA₁ of Christopher A Kennedy , Mark H Carpenter  (2019).\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#TimeMachine.ARK548L2SA2KennedyCarpenter","page":"Algorithms","title":"TimeMachine.ARK548L2SA2KennedyCarpenter","text":"ARK548L2SA2KennedyCarpenter(linsolve)\n\nThe fifth-order, 8-stage additive Runge–Kutta scheme ARK5(4)8L[2]SA₂ of Christopher A Kennedy , Mark H Carpenter  (2019).\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#Multirate","page":"Algorithms","title":"Multirate","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"Multirate","category":"page"},{"location":"algorithms/#TimeMachine.Multirate","page":"Algorithms","title":"TimeMachine.Multirate","text":"Multirate(fast, slow)\n\nA multirate Runge–Kutta scheme, combining fast and slow algorithms\n\nslow can be any algorithm providing methods for the following functions\n\ninit_inner(prob, outercache, dt)\nupdate_inner!(innerinteg, outercache, f_slow, u, p, t, dt, stage)\n\nAlgorithms which currently support this are:\n\nLowStorageRungeKutta2N\nMultirateInfinitesimalStep\nWickerSkamarockRungeKutta\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#Multirate-Infinitesimal-Step","page":"Algorithms","title":"Multirate Infinitesimal Step","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"MultirateInfinitesimalStep\nMIS2\nMIS3C\nMIS4\nMIS4a\nTVDMISA\nTVDMISB","category":"page"},{"location":"algorithms/#TimeMachine.MultirateInfinitesimalStep","page":"Algorithms","title":"TimeMachine.MultirateInfinitesimalStep","text":"MultirateInfinitesimalStep\n\nMultirate Infinitesimal Step (MIS) methods of J { \\ \" o } rg Wensch , Oswald Knoth , Alexander Galant  (2009) and Oswald Knoth , Joerg Wensch  (2014).\n\nThe available implementations are:\n\nMIS2\nMIS3C\nMIS4\nMIS4a\nTVDMISA\nTVDMISB\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#TimeMachine.MIS2","page":"Algorithms","title":"TimeMachine.MIS2","text":"MIS2()\n\nThe MIS2 Multirate Infinitesimal Step (MIS) method of Oswald Knoth , Joerg Wensch  (2014).\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#TimeMachine.MIS3C","page":"Algorithms","title":"TimeMachine.MIS3C","text":"MIS3C()\n\nThe MIS3C Multirate Infinitesimal Step (MIS) method of Oswald Knoth , Joerg Wensch  (2014).\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#TimeMachine.MIS4","page":"Algorithms","title":"TimeMachine.MIS4","text":"MIS4()\n\nThe MIS4 Multirate Infinitesimal Step (MIS) method of Oswald Knoth , Joerg Wensch  (2014).\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#TimeMachine.MIS4a","page":"Algorithms","title":"TimeMachine.MIS4a","text":"MIS4a()\n\nThe MIS4a Multirate Infinitesimal Step (MIS) method of Oswald Knoth , Joerg Wensch  (2014).\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#TimeMachine.TVDMISA","page":"Algorithms","title":"TimeMachine.TVDMISA","text":"TVDMISA()\n\nThe TVDMISA Total Variation Diminishing (TVD) Multirate Infinitesimal Step (MIS) method of Oswald Knoth , Joerg Wensch  (2014).\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#TimeMachine.TVDMISB","page":"Algorithms","title":"TimeMachine.TVDMISB","text":"TVDMISB()\n\nThe TVDMISB Total Variation Diminishing (TVD) Multirate Infinitesimal Step (MIS) method of Oswald Knoth , Joerg Wensch  (2014).\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#Wicker–Skamarock","page":"Algorithms","title":"Wicker–Skamarock","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"WickerSkamarockRungeKutta\nWSRK2\nWSRK3","category":"page"},{"location":"algorithms/#TimeMachine.WickerSkamarockRungeKutta","page":"Algorithms","title":"TimeMachine.WickerSkamarockRungeKutta","text":"WickerSkamarockRungeKutta <: DistributedODEAlgorithm\n\nClass of multirate algorithms developed in Louis J Wicker , William C Skamarock  (1998) and Louis J Wicker , William C Skamarock  (2002), which can be used as slow methods in Multirate.\n\nThese require two additional copies of the state vector u.\n\nAvailable implementations are:\n\nWSRK2\nWSRK3\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#TimeMachine.WSRK2","page":"Algorithms","title":"TimeMachine.WSRK2","text":"WSRK2()\n\nThe 2 stage, 2nd order RK2 scheme of Louis J Wicker , William C Skamarock  (1998).\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#TimeMachine.WSRK3","page":"Algorithms","title":"TimeMachine.WSRK3","text":"WSRK3()\n\nThe 3 stage, 2nd order (3rd order for linear problems) RK3 scheme of Louis J Wicker , William C Skamarock  (2002).\n\n\n\n\n\n","category":"type"}]
}
