<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Non-linear solvers · ClimaTimeSteppers</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ClimaTimeSteppers</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">ClimaTimeSteppers.jl</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Algorithm formulations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../algo_formulations/lsrk/">Low-storage Runge–Kutta methods</a></li><li><a class="tocitem" href="../../algo_formulations/ssprk/">Strong Stability Preserving Runge–Kutta methods</a></li><li><a class="tocitem" href="../../algo_formulations/ark/">Additive Runge–Kutta</a></li><li><a class="tocitem" href="../../algo_formulations/mrrk/">Multirate Runge Kutta</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Non-linear solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../nl_solvers/formulation/">Formulation</a></li><li><a class="tocitem" href="../../nl_solvers/newtons_method/">Newtons method</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Test problems</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../test_problems/">Test problems</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox" checked/><label class="tocitem" for="menuitem-5"><span class="docs-label">API docs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../algorithms/">Algorithms</a></li><li><a class="tocitem" href="../tableaus/">Tableaus</a></li><li class="is-active"><a class="tocitem" href>Non-linear solvers</a><ul class="internal"><li><a class="tocitem" href="#Newton-Krylov-Method"><span>Newton-Krylov Method</span></a></li><li><a class="tocitem" href="#Jacobian-free-Newton-Krylov-Method"><span>Jacobian-free Newton-Krylov Method</span></a></li><li><a class="tocitem" href="#Convergence-Conditions"><span>Convergence Conditions</span></a></li><li><a class="tocitem" href="#Update-Signals"><span>Update Signals</span></a></li></ul></li><li><a class="tocitem" href="../callbacks/">Callbacks</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Developer docs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../dev/types/">Types</a></li><li><a class="tocitem" href="../../dev/report_gen/">Report generator</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API docs</a></li><li class="is-active"><a href>Non-linear solvers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Non-linear solvers</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/CliMA/ClimaTimeSteppers.jl/blob/main/docs/src/api/nl_solvers.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Newton&#39;s-Method"><a class="docs-heading-anchor" href="#Newton&#39;s-Method">Newton&#39;s Method</a><a id="Newton&#39;s-Method-1"></a><a class="docs-heading-anchor-permalink" href="#Newton&#39;s-Method" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="ClimaTimeSteppers.NewtonsMethod" href="#ClimaTimeSteppers.NewtonsMethod"><code>ClimaTimeSteppers.NewtonsMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NewtonsMethod(;
    max_iters = 1,
    update_j = UpdateEvery(NewNewtonIteration),
    krylov_method = nothing,
    convergence_checker = nothing,
    verbose = Silent(),
)</code></pre><p>Solves the equation <code>f(x) = 0</code>, using the Jacobian (or an approximation of the Jacobian) <code>j(x) = f&#39;(x)</code> if it is available. This is done by calling <code>solve_newton!(::NewtonsMethod, cache, x, f!, j! = nothing)</code>, where <code>f!(f, x)</code> is a function that sets <code>f(x)</code> in-place and, if it is specified, <code>j!(j, x)</code> is a function that sets <code>j(x)</code> in-place. The <code>x</code> passed to Newton&#39;s method is modified in-place, and its initial value is used as a starting guess for the root. The <code>cache</code> can be obtained with <code>allocate_cache(::NewtonsMethod, x_prototype, j_prototype = nothing)</code>, where <code>x_prototype</code> is <code>similar</code> to <code>x</code> and <code>f(x)</code>, and, if it is specified, <code>j_prototype</code> is <code>similar</code> to <code>j(x)</code>. In order for <code>j(x)</code> to be invertible, it must be a square matrix, which implies that <code>x</code> and <code>f(x)</code> must be <code>similar</code> to to each other.</p><p>Let <code>x[n]</code> denote the value of <code>x</code> on the <code>n</code>-th Newton iteration (with <code>x[0]</code> denoting the initial value of <code>x</code>), and suppose that <code>x[n]</code> is sufficiently close to some root <code>x̂</code> of <code>f(x)</code> to make the first-order approximation     <code>f(x̂) ≈ f(x[n]) + j(x[n]) * (x̂ - x[n])</code>. Since <code>f(x̂) = 0</code>, the error on the <code>n</code>-th iteration is roughly     <code>x[n] - x̂ ≈ Δx[n]</code>, where <code>Δx[n] = j(x[n]) \ f(x[n])</code>. Newton&#39;s method sets <code>x[n + 1]</code> to be the value of <code>x̂</code> given by this approximation:     <code>x[n + 1] = x[n] - Δx[n]</code>.</p><p>If a Krylov method is specified, it gets used to compute the error <code>Δx[n] = j(x[n]) \ f(x[n])</code>; otherwise, the error is directly computed by calling <code>ldiv!(Δx, j, f)</code>. If the Krylov method uses a Jacobian-free JVP (Jacobian-vector product), <code>j_prototype</code> and <code>j!</code> do not need to be specified. When Newton&#39;s method uses a Krylov method, it is called a &quot;Newton-Krylov method&quot;; furthermore, when the Krylov method uses a Jacobian-free JVP, it is called a &quot;Jacobian-free Newton-Krylov method&quot;.</p><p>If <code>j_prototype</code> is specified, it should not be an <code>DenseMatrix</code>. If it is, it has to be factorized with <code>lu</code> before <code>ldiv!</code> is called, which requires the allocation of additional memory. Instead, <code>j_prototype</code> should be an object that can directly be passed to <code>ldiv!</code>. For convenience, though, the use of an <code>DenseMatrix</code> is supported. However, <code>Krylov.jl</code> does not provide such support for its preconditioners, so, since the value computed with <code>j!</code> is used as a preconditioner in Krylov methods with a Jacobian-free JVP, using such a Krylov method requires specifying a <code>j_prototype</code> that can be passed to <code>ldiv!</code>.</p><p>If <code>j(x)</code> changes sufficiently slowly, <code>update_j</code> may be changed from <code>UpdateEvery(NewNewtonIteration)</code> to some other <code>UpdateSignalHandler</code> that gets triggered less frequently, such as <code>UpdateEvery(NewNewtonSolve)</code>. This can be used to make the approximation <code>j(x[n]) ≈ j(x₀)</code>, where <code>x₀</code> is a previous value of <code>x[n]</code> (possibly even a value from a previous <code>solve_newton!</code> of Newton&#39;s method). When Newton&#39;s method uses such an approximation, it is called the &quot;chord method&quot;.</p><p>In addition, <code>update_j</code> can be set to an <code>UpdateSignalHandler</code> that gets triggered by signals that originate outside of Newton&#39;s method, such as <code>UpdateEvery(NewTimeStep)</code>. It is possible to send any signal for updating <code>j</code> to Newton&#39;s method while it is not running by calling <code>update!(::NewtonsMethod, cache, ::UpdateSignal, j!)</code>, where in this case <code>j!(j)</code> is a function that sets <code>j</code> in-place without any dependence on <code>x</code> (since <code>x</code> is not necessarily defined while Newton&#39;s method is not running, this version of <code>j!</code> does not take <code>x</code> as an argument). This can be used to make the approximation <code>j(x[n]) ≈ j₀</code>, where <code>j₀</code> can have an arbitrary value.</p><p>If a convergence checker is provided, it gets used to determine whether to stop iterating on iteration <code>n</code> based on the value <code>x[n]</code> and its error <code>Δx[n]</code>; otherwise, Newton&#39;s method iterates from <code>n = 0</code> to <code>n = max_iters</code>. If the convergence checker determines that <code>x[n]</code> has not converged by the time <code>n = max_iters</code>, a warning gets printed.</p><p>If <code>verbose</code> is set to <code>true</code>, the norms of <code>x[n]</code> and <code>Δx[n]</code> get printed on every iteration. If there is no convergence checker, <code>Δx[n]</code> is not computed on the last iteration, so its final norm is not printed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaTimeSteppers.jl/blob/32551d3c8f56b95a41a16005cc34a73a88e5a380/src/nl_solvers/newtons_method.jl#L467-L543">source</a></section></article><h2 id="Newton-Krylov-Method"><a class="docs-heading-anchor" href="#Newton-Krylov-Method">Newton-Krylov Method</a><a id="Newton-Krylov-Method-1"></a><a class="docs-heading-anchor-permalink" href="#Newton-Krylov-Method" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ClimaTimeSteppers.KrylovMethod" href="#ClimaTimeSteppers.KrylovMethod"><code>ClimaTimeSteppers.KrylovMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">KrylovMethod(;
    type = Val(Krylov.GmresSolver),
    jacobian_free_jvp = nothing,
    forcing_term = ConstantForcing(0),
    args = (20,),
    kwargs = (;),
    solve_kwargs = (;),
    disable_preconditioner = false,
    verbose = Silent(),
    debugger = nothing,
)</code></pre><p>Finds an approximation <code>Δx[n] ≈ j(x[n]) \ f(x[n])</code> for Newton&#39;s method such that <code>‖f(x[n]) - j(x[n]) * Δx[n]‖ ≤ rtol[n] * ‖f(x[n])‖</code>, where <code>rtol[n]</code> is the value of the forcing term on iteration <code>n</code>. This is done by calling <code>solve_krylov!(::KrylovMethod, cache, Δx, x, f!, f, n, j = nothing)</code>, where <code>f</code> is <code>f(x[n])</code> and, if it is specified, <code>j</code> is either <code>j(x[n])</code> or an approximation of <code>j(x[n])</code>. The <code>Δx</code> passed to a Krylov method is modified in-place. The <code>cache</code> can be obtained with <code>allocate_cache(::KrylovMethod, x_prototype)</code>, where <code>x_prototype</code> is <code>similar</code> to <code>x</code> (and also to <code>Δx</code> and <code>f</code>).</p><p>This is primarily a wrapper for a <code>Krylov.KrylovSolver</code> from <code>Krylov.jl</code>. In <code>allocate_cache</code>, the solver is constructed with <code>solver = type(l, l, args..., Krylov.ktypeof(x_prototype); kwargs...)</code>, where <code>l = length(x_prototype)</code> and <code>Krylov.ktypeof(x_prototype)</code> is a subtype of <code>DenseVector</code> that can be used to store <code>x_prototype</code>. By default, the solver is a <code>Krylov.GmresSolver</code> with a Krylov subspace size of 20 (the default Krylov subspace size for this solver in <code>Krylov.jl</code>). In <code>solve_krylov!</code>, the solver is run with <code>Krylov.solve!(solver, opj, f; M, ldiv, atol, rtol, verbose, solve_kwargs...)</code>. The solver&#39;s type can be changed by specifying a different value for <code>type</code>, though this value has to be wrapped in a <code>Val</code> to avoid runtime compilation.</p><p>In the call to <code>Krylov.solve!</code>, <code>opj</code> is a <code>LinearOperator</code> that represents <code>j(x[n])</code>, which the solver uses by evaluating <code>mul!(jΔx, opj, Δx)</code>. If a Jacobian-free JVP (Jacobian-vector product) is specified, it gets used to construct <code>opj</code> and to evaluate the calls to <code>mul!</code>; otherwise, <code>j</code> itself gets used to construct <code>opj</code>, and the calls to <code>mul!</code> simplify to <code>mul!(jΔx, j, Δx)</code>.</p><p>If a Jacobian-free JVP and <code>j</code> are both specified, and if <code>disable_preconditioner</code> is set to <code>false</code>, <code>j</code> is treated as an approximation of <code>j(x[n])</code> and is used as the (left) preconditioner <code>M</code> in order to speed up the solver; otherwise, the preconditioner is simply set to the identity matrix <code>I</code>. The keyword argument <code>ldiv</code> is set to <code>true</code> so that the solver calls <code>ldiv!(Δx′, M, f′)</code> instead of <code>mul!(Δx′, M, f′)</code>, where <code>Δx′</code> and <code>f′</code> denote internal variables of the solver that roughly correspond to <code>Δx</code> and <code>f</code>. In other words, setting <code>ldiv</code> to <code>true</code> makes the solver treat <code>M</code> as an approximation of <code>j</code> instead of as the inverse of an approximation of <code>j</code>.</p><p>The keyword argument <code>atol</code> is set to 0 because, if it is set to some other value, the inequality <code>‖f(x[n]) - j(x[n]) * Δx[n]‖ ≤ rtol[n] * ‖f(x[n])‖</code> changes to <code>‖f(x[n]) - j(x[n]) * Δx[n]‖ ≤ rtol[n] * ‖f(x[n])‖ + atol</code>, which eliminates any convergence guarantees provided by the forcing term (in order for the Newton-Krylov method to converge, the right-hand side of this inequality must approach 0 as <code>n</code> increases, which cannot happen if <code>atol</code> is not 0).</p><p>All of the arguments and keyword arguments used to construct and run the solver can be modified using <code>args</code>, <code>kwargs</code>, and <code>solve_kwargs</code>. So, the default behavior of this wrapper can be easily overwritten, and any features of <code>Krylov.jl</code> that are not explicitly covered by this wrapper can still be used.</p><p>If <code>verbose</code> is <code>true</code>, the residual <code>‖f(x[n]) - j(x[n]) * Δx[n]‖</code> is printed on each iteration of the Krylov method. If a debugger is specified, it is run before the call to <code>Kyrlov.solve!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaTimeSteppers.jl/blob/32551d3c8f56b95a41a16005cc34a73a88e5a380/src/nl_solvers/newtons_method.jl#L330-L394">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaTimeSteppers.ForcingTerm" href="#ClimaTimeSteppers.ForcingTerm"><code>ClimaTimeSteppers.ForcingTerm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ForcingTerm</code></pre><p>Computes the value of <code>rtol[n]</code> for a Newton-Krylov method. This is done by calling <code>get_rtol!(::ForcingTerm, cache, f, n)</code>, which returns <code>rtol[n]</code>. The <code>cache</code> can be obtained with <code>allocate_cache(::ForcingTerm, x_prototype)</code>, where <code>x_prototype</code> is <code>similar</code> to <code>f</code>.</p><p>For a detailed discussion of forcing terms and their convergence guarantees, see &quot;Choosing the Forcing Terms in an Inexact Newton Method&quot; by S.C. Eisenstat and H.F. Walker (http://softlib.rice.edu/pub/CRPC-TRs/reports/CRPC-TR94463.pdf).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaTimeSteppers.jl/blob/32551d3c8f56b95a41a16005cc34a73a88e5a380/src/nl_solvers/newtons_method.jl#L165-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaTimeSteppers.ConstantForcing" href="#ClimaTimeSteppers.ConstantForcing"><code>ClimaTimeSteppers.ConstantForcing</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConstantForcing(rtol)</code></pre><p>A <code>ForcingTerm</code> that always returns the value <code>rtol</code>, which must be in the interval <code>[0, 1)</code>. If <code>x</code> and <code>f!</code> satisfy certain assumptions, this forcing term guarantees that the Newton-Krylov method will converge linearly with an asymptotic rate of at most <code>rtol</code>. If <code>rtol</code> is 0 (or <code>eps(FT)</code>), this forces the approximation of <code>Δx[n]</code> to be exact (or exact to within machine precision) and guarantees that the Newton-Krylov method will converge quadratically. Note that, although a smaller value of <code>rtol</code> guarantees faster asymptotic convergence, it also leads to a higher probability of oversolving.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaTimeSteppers.jl/blob/32551d3c8f56b95a41a16005cc34a73a88e5a380/src/nl_solvers/newtons_method.jl#L179-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaTimeSteppers.EisenstatWalkerForcing" href="#ClimaTimeSteppers.EisenstatWalkerForcing"><code>ClimaTimeSteppers.EisenstatWalkerForcing</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EisenstatWalkerForcing(;
    initial_rtol = 0.5,
    γ = 1,
    α = 2,
    min_rtol_threshold = 0.1,
    max_rtol = 0.9,
)</code></pre><p>The <code>ForcingTerm</code> called &quot;Choice 2&quot; in the paper &quot;Choosing the Forcing Terms in an Inexact Newton Method&quot; by S.C. Eisenstat and H.F. Walker. The values of <code>initial_rtol</code>, <code>min_rtol_threshold</code>, and <code>max_rtol</code> must be in the interval <code>[0, 1)</code>, the value of <code>γ</code> must be in the interval <code>[0, 1]</code>, and the value of <code>α</code> must be in the interval <code>(1, 2]</code>. These values can all be tuned to prevent the Newton-Krylov method from oversolving. If <code>x</code> and <code>f!</code> satisfy certain assumptions, this forcing term guarantees that the Newton-Krylov method will converge with order <code>α</code>. Note that, although a larger value of <code>α</code> guarantees a higher convergence order, it also leads to a higher probability of oversolving.</p><p>This forcing term was implemented instead of the one called &quot;Choice 1&quot; because it has a significantly simpler implementation–-it only requires the value of <code>‖f(x[n])‖</code> to compute <code>rtol[n]</code>, whereas &quot;Choice 1&quot; also requires the norm of the final residual from the Krylov solver.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaTimeSteppers.jl/blob/32551d3c8f56b95a41a16005cc34a73a88e5a380/src/nl_solvers/newtons_method.jl#L202-L225">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaTimeSteppers.KrylovMethodDebugger" href="#ClimaTimeSteppers.KrylovMethodDebugger"><code>ClimaTimeSteppers.KrylovMethodDebugger</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">KrylovMethodDebugger</code></pre><p>Prints information about the Jacobian matrix <code>j</code> and the preconditioner <code>M</code> (if it is available) that are passed to a Krylov method. This is done by calling <code>print_debug!(::KrylovMethodDebugger, cache, j, M)</code>. The <code>cache</code> can be obtained with <code>allocate_cache(::KrylovMethodDebugger, x_prototype)</code>, where <code>x_prototype</code> is <code>similar</code> to <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaTimeSteppers.jl/blob/32551d3c8f56b95a41a16005cc34a73a88e5a380/src/nl_solvers/newtons_method.jl#L260-L268">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaTimeSteppers.PrintConditionNumber" href="#ClimaTimeSteppers.PrintConditionNumber"><code>ClimaTimeSteppers.PrintConditionNumber</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PrintConditionNumber()</code></pre><p>Prints the condition number of the Jacobian matrix <code>j</code>, and, if a preconditioner <code>M</code> is available, also prints the condition number of <code>inv(M) * j</code> (i.e., the matrix that actually gets &quot;inverted&quot; by the Krylov method). This requires computing dense representations of <code>j</code> and <code>inv(M) * j</code>, which is likely to be significantly slower than the Krylov method itself.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaTimeSteppers.jl/blob/32551d3c8f56b95a41a16005cc34a73a88e5a380/src/nl_solvers/newtons_method.jl#L271-L279">source</a></section></article><h2 id="Jacobian-free-Newton-Krylov-Method"><a class="docs-heading-anchor" href="#Jacobian-free-Newton-Krylov-Method">Jacobian-free Newton-Krylov Method</a><a id="Jacobian-free-Newton-Krylov-Method-1"></a><a class="docs-heading-anchor-permalink" href="#Jacobian-free-Newton-Krylov-Method" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ClimaTimeSteppers.JacobianFreeJVP" href="#ClimaTimeSteppers.JacobianFreeJVP"><code>ClimaTimeSteppers.JacobianFreeJVP</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">JacobianFreeJVP</code></pre><p>Computes the Jacobian-vector product <code>j(x[n]) * Δx[n]</code> for a Newton-Krylov method without directly using the Jacobian <code>j(x[n])</code>, and instead only using <code>x[n]</code>, <code>f(x[n])</code>, and other function evaluations <code>f(x′)</code>. This is done by calling <code>jvp!(::JacobianFreeJVP, cache, jΔx, Δx, x, f!, f)</code>. The <code>jΔx</code> passed to a Jacobian-free JVP is modified in-place. The <code>cache</code> can be obtained with <code>allocate_cache(::JacobianFreeJVP, x_prototype)</code>, where <code>x_prototype</code> is <code>similar</code> to <code>x</code> (and also to <code>Δx</code> and <code>f</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaTimeSteppers.jl/blob/32551d3c8f56b95a41a16005cc34a73a88e5a380/src/nl_solvers/newtons_method.jl#L128-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaTimeSteppers.ForwardDiffJVP" href="#ClimaTimeSteppers.ForwardDiffJVP"><code>ClimaTimeSteppers.ForwardDiffJVP</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ForwardDiffJVP(; default_step = ForwardDiffStepSize3(), step_adjustment = 1)</code></pre><p>Computes the Jacobian-vector product using the forward difference approximation <code>j(x) * Δx = (f(x + ε * Δx) - f(x)) / ε</code>, where <code>ε = step_adjustment * default_step(Δx, x)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaTimeSteppers.jl/blob/32551d3c8f56b95a41a16005cc34a73a88e5a380/src/nl_solvers/newtons_method.jl#L141-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaTimeSteppers.ForwardDiffStepSize" href="#ClimaTimeSteppers.ForwardDiffStepSize"><code>ClimaTimeSteppers.ForwardDiffStepSize</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ForwardDiffStepSize</code></pre><p>Computes a default step size for the forward difference approximation of the Jacobian-vector product. This is done by calling <code>default_step(Δx, x)</code>, where <code>default_step</code> is a <code>ForwardDiffStepSize</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaTimeSteppers.jl/blob/32551d3c8f56b95a41a16005cc34a73a88e5a380/src/nl_solvers/newtons_method.jl#L21-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaTimeSteppers.ForwardDiffStepSize1" href="#ClimaTimeSteppers.ForwardDiffStepSize1"><code>ClimaTimeSteppers.ForwardDiffStepSize1</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ForwardDiffStepSize1()</code></pre><p>A <code>ForwardDiffStepSize</code> that is derived based on the notes here: https://web.engr.oregonstate.edu/~webbky/MAE4020<em>5020</em>files/Section%204%20Roundoff%20and%20Truncation%20Error.pdf. Although it is not often used with Newton-Krylov methods in practice, it can provide some intuition for for how to set the value of <code>step_adjustment</code> in a <code>ForwardDiffJVP</code>.</p><p>The first-order Taylor series expansion of <code>f(x + ε * Δx)</code> around <code>x</code> is     <code>f(x + ε * Δx) = f(x) + j(x) * (ε * Δx) + e_trunc(x, ε * Δx)</code>, where <code>j(x) = f&#39;(x)</code> and <code>e_trunc</code> is the expansion&#39;s truncation error. Due to roundoff error, we are unable to directly compute the value of <code>f(x)</code>; instead, we can only determine <code>f̂(x)</code>, where     <code>f(x) = f̂(x) + e_round(x)</code>. Substituting this into the expansion tells us that     <code>f̂(x + ε * Δx) + e_round(x + ε * Δx) =         f̂(x) + e_round(x) + j(x) * (ε * Δx) + e_trunc(x, ε * Δx)</code>. Rearranging this gives us the Jacobian-vector product     <code>j(x) * Δx = (f̂(x + ε * Δx) - f̂(x)) / ε - e_trunc(x, ε * Δx) / ε +                  (e_round(x + ε * Δx) - e_round(x)) / ε</code>. So, the normed error of the forward difference approximation of this product is     <code>‖error‖ = ‖(f̂(x + ε * Δx) - f̂(x)) / ε - j(x) * Δx‖ =              = ‖e_trunc(x, ε * Δx) - e_round(x + ε * Δx) + e_round(x)‖ / ε</code>. We can use the triangle inequality to get the upper bound     <code>‖error‖ ≤         (‖e_trunc(x, ε * Δx)‖ + ‖e_round(x + ε * Δx)‖ + ‖e_round(x)‖) / ε</code>. If <code>ε</code> is sufficiently small, we can approximate     <code>‖e_round(x + ε * Δx)‖ ≈ ‖e_round(x)‖</code>. This simplifies the upper bound to     <code>‖error‖ ≤ (‖e_trunc(x, ε * Δx)‖ + 2 * ‖e_round(x)‖) / ε</code>.</p><p>From Taylor&#39;s theorem (for multivariate vector-valued functions), the truncation error of the first-order expansion is bounded by     <code>‖e_trunc(x, ε * Δx)‖ ≤ (sup_{x̂ ∈ X} ‖f&#39;&#39;(x̂)‖) / 2 * ‖ε * Δx‖^2</code>, where <code>X</code> is a closed ball around <code>x</code> that contains <code>x + ε * Δx</code> (see https://math.stackexchange.com/questions/3478229 for a proof of this). Let us define the value     <code>S = ‖f(x)‖ / sup_{x̂ ∈ X} ‖f&#39;&#39;(x̂)‖</code>. By default, we will assume that <code>S ≈ 1</code>, but we will let users pass other values to indicate the &quot;smoothness&quot; of <code>f(x)</code> (a large value of <code>S</code> should indicate that the Hessian tensor of <code>f(x)</code> has a small norm compared to <code>f(x)</code> itself). We then have that     <code>‖e_trunc(x, ε * Δx)‖| ≤ ε^2 / (2 * S) * ‖Δx‖^2 * ‖f(x)‖</code>.</p><p>If only the last bit in each component of <code>f(x)</code> can be altered by roundoff error, then the <code>i</code>-th component of <code>e_round(x)</code> is bounded by     <code>|e_round(x)[i]| ≤ eps(f(x)[i])</code>. More generally, we can assume that there is some constant <code>R</code> (by default, we will assume that <code>R ≈ 1</code>) such that     <code>|e_round(x)[i]| ≤ R * eps(f(x)[i])</code>. We can also make the approximation (which is accurate to within <code>eps(FT)</code>)     <code>eps(f(x)[i]) ≈ eps(FT) * |f(x)[i]|</code>. This implies that     <code>|e_round(x)[i]| ≤ R * eps(FT) * |f(x)[i]|</code>. Since this is true for every component of <code>e_round(x)</code> and <code>f(x)</code>, we find that     <code>‖e_round(x)‖ ≤ R * eps(FT) * ‖f(x)‖</code>.</p><p>Substituting the bounds on the truncation and roundoff errors into the bound on the overall error gives us     <code>‖error‖ ≤ ε / (2 * S) * ‖Δx‖^2 * ‖f(x)‖ + 2 / ε * R * eps(FT) * ‖f(x)‖</code>. Differentiating the right-hand side with respect to <code>ε</code> and setting the result equal to 0 (and noting that the second derivative is always positive) tells us that this upper bound is minimized when     <code>ε = step_adjustment * sqrt(eps(FT)) / ‖Δx‖</code>, where <code>step_adjustment = 2 * sqrt(S * R)</code>. By default, we will assume that <code>step_adjustment = 1</code>, but it should be made larger when <code>f</code> is very smooth or has a large roundoff error.</p><p>Note that, if we were to replace the forward difference approximation in the derivation above with a central difference approximation, the square root would end up being replaced with a cube root (or, more generally, with an <code>n</code>-th root for a finite difference approximation of order <code>n - 1</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaTimeSteppers.jl/blob/32551d3c8f56b95a41a16005cc34a73a88e5a380/src/nl_solvers/newtons_method.jl#L30-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaTimeSteppers.ForwardDiffStepSize2" href="#ClimaTimeSteppers.ForwardDiffStepSize2"><code>ClimaTimeSteppers.ForwardDiffStepSize2</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ForwardDiffStepSize2()</code></pre><p>A <code>ForwardDiffStepSize</code> that is described in the paper &quot;Jacobian-free Newton–Krylov methods: a survey of approaches and applications&quot; by D.A. Knoll and D.E. Keyes. According to the paper, this is the step size used by the Fortran package NITSOL.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaTimeSteppers.jl/blob/32551d3c8f56b95a41a16005cc34a73a88e5a380/src/nl_solvers/newtons_method.jl#L106-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaTimeSteppers.ForwardDiffStepSize3" href="#ClimaTimeSteppers.ForwardDiffStepSize3"><code>ClimaTimeSteppers.ForwardDiffStepSize3</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ForwardDiffStepSize3()</code></pre><p>A <code>ForwardDiffStepSize</code> that is described in the paper &quot;Jacobian-free Newton–Krylov methods: a survey of approaches and applications&quot; by D.A. Knoll and D.E. Keyes. According to the paper, this is the average step size one gets when using a certain forward difference approximation for each Jacobian element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaTimeSteppers.jl/blob/32551d3c8f56b95a41a16005cc34a73a88e5a380/src/nl_solvers/newtons_method.jl#L117-L124">source</a></section></article><h2 id="Convergence-Conditions"><a class="docs-heading-anchor" href="#Convergence-Conditions">Convergence Conditions</a><a id="Convergence-Conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Convergence-Conditions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ClimaTimeSteppers.ConvergenceChecker" href="#ClimaTimeSteppers.ConvergenceChecker"><code>ClimaTimeSteppers.ConvergenceChecker</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConvergenceChecker(;
    norm_condition,
    component_condition,
    condition_combiner,
    norm = LinearAlgebra.norm,
)</code></pre><p>Checks whether a sequence <code>val[0], val[1], val[2], ...</code> has converged to some limit <code>L</code>, given the errors <code>err[iter] = val[iter] .- L</code>. This is done by calling <code>check_convergence!(::ConvergenceChecker, cache, val, err, iter)</code>, where <code>val = val[iter]</code> and <code>err = err[iter]</code>. If the value of <code>L</code> is not known, <code>err</code> can be an approximation of <code>err[iter]</code>. The <code>cache</code> for a <code>ConvergenceChecker</code> can be obtained with <code>allocate_cache(::ConvergenceChecker, val_prototype)</code>, where <code>val_prototype</code> is <code>similar</code> to <code>val</code> and <code>err</code>.</p><p>A <code>ConvergenceChecker</code> can perform two types of checks–-it can check whether <code>norm(val)</code> and <code>norm(err)</code> satisfy some <code>ConvergenceCondition</code>, and it can check whether all the components of <code>abs.(val)</code> and <code>abs.(err)</code> individually satisfy some <code>ConvergenceCondition</code>. These two checks can be combined with either <code>&amp;</code> or <code>|</code>. If one of the checks is not needed, the corresponding <code>ConvergenceCondition</code> can be set to <code>nothing</code>.</p><p>Instead of <code>LinearAlgebra.norm</code>, <code>norm</code> can be set to anything that will convert <code>val</code> and <code>err</code> to non-negative scalar values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaTimeSteppers.jl/blob/32551d3c8f56b95a41a16005cc34a73a88e5a380/src/utilities/convergence_checker.jl#L5-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaTimeSteppers.ConvergenceCondition" href="#ClimaTimeSteppers.ConvergenceCondition"><code>ClimaTimeSteppers.ConvergenceCondition</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConvergenceCondition</code></pre><p>An abstract type for objects that can check whether a sequence of non-negative scalar values <code>val[0], val[1], val[2], ...</code> has converged to some limit <code>L</code>, given the errors <code>err[iter] = |val[iter] - L|</code>.</p><p>Every subtype of <code>ConvergenceCondition</code> must define     <code>has_converged(::ConvergenceCondition, cache, val, err, iter)</code>. The <code>cache</code>, which is set to <code>nothing</code> by default, may be used to store information from previous iterations that is useful for determining convergence. In order to have access to a <code>cache</code> of some particular type, a subtype of <code>ConvergenceCondition</code> should define     <code>cache_type(::ConvergenceCondition, ::Type{FT})</code>. To specify on which iterations this cache should be updated, it should define     <code>needs_cache_update(::ConvergenceCondition, iter)</code>. To specify how the cache should be update on those iterations, it should define     <code>updated_cache(::ConvergenceCondition, cache, val, err, iter)</code>.</p><p>Although <code>cache_type</code> can call <code>promote_type</code> to prevent potential type instability errors, this should be avoided in order to ensure that users write type-stable code.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaTimeSteppers.jl/blob/32551d3c8f56b95a41a16005cc34a73a88e5a380/src/utilities/convergence_condition.jl#L4-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaTimeSteppers.MaximumError" href="#ClimaTimeSteppers.MaximumError"><code>ClimaTimeSteppers.MaximumError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MaximumError(max_err)</code></pre><p>Checks whether <code>err[iter] ≤ max_err</code>. Since <code>err[iter] ≥ 0</code>, this can only be <code>true</code> if <code>max_err ≥ 0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaTimeSteppers.jl/blob/32551d3c8f56b95a41a16005cc34a73a88e5a380/src/utilities/convergence_condition.jl#L31-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaTimeSteppers.MaximumRelativeError" href="#ClimaTimeSteppers.MaximumRelativeError"><code>ClimaTimeSteppers.MaximumRelativeError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MaximumRelativeError(max_rel_err)</code></pre><p>Checks whether <code>err[iter] ≤ max_rel_err * val[iter]</code>. Since <code>err[iter] ≥ 0</code> and <code>val[iter] ≥ 0</code>, this can only be <code>true</code> if <code>max_rel_err ≥ 0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaTimeSteppers.jl/blob/32551d3c8f56b95a41a16005cc34a73a88e5a380/src/utilities/convergence_condition.jl#L42-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaTimeSteppers.MaximumErrorReduction" href="#ClimaTimeSteppers.MaximumErrorReduction"><code>ClimaTimeSteppers.MaximumErrorReduction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MaximumErrorReduction(max_reduction)</code></pre><p>Checks whether <code>err[iter] ≤ max_reduction * err[0]</code> for all <code>iter ≥ 1</code>. Since <code>err[iter] ≥ 0</code>, this can only be <code>true</code> if <code>max_reduction ≥ 0</code>. Also, it must be the case that <code>max_reduction ≤ 1</code> in order for the sequence to not diverge (i.e., to avoid <code>err[iter] &gt; err[0]</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaTimeSteppers.jl/blob/32551d3c8f56b95a41a16005cc34a73a88e5a380/src/utilities/convergence_condition.jl#L53-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaTimeSteppers.MinimumRateOfConvergence" href="#ClimaTimeSteppers.MinimumRateOfConvergence"><code>ClimaTimeSteppers.MinimumRateOfConvergence</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MinimumRateOfConvergence(rate, order = 1)</code></pre><p>Checks whether <code>err[iter] ≥ rate * err[iter - 1]^order</code> for all <code>iter ≥ 1</code>. Since <code>err[iter] ≥ 0</code>, this can only be <code>true</code> if <code>rate ≥ 0</code>. Also, if <code>order == 1</code>, it must be the case that <code>rate ≤ 1</code> in order for the sequence to not diverge (i.e., to avoid <code>err[iter] &gt; err[iter - 1]</code>). In addition, if <code>err[iter] &lt; 1</code> for all sufficiently large values of <code>iter</code>, it must be the case that <code>order ≥ 1</code> for the sequence to not diverge.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaTimeSteppers.jl/blob/32551d3c8f56b95a41a16005cc34a73a88e5a380/src/utilities/convergence_condition.jl#L69-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaTimeSteppers.MultipleConditions" href="#ClimaTimeSteppers.MultipleConditions"><code>ClimaTimeSteppers.MultipleConditions</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MultipleConditions(condition_combiner = all, conditions...)</code></pre><p>Checks multiple <code>ConvergenceCondition</code>s, combining their results with either <code>all</code> or <code>any</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaTimeSteppers.jl/blob/32551d3c8f56b95a41a16005cc34a73a88e5a380/src/utilities/convergence_condition.jl#L89-L94">source</a></section></article><h2 id="Update-Signals"><a class="docs-heading-anchor" href="#Update-Signals">Update Signals</a><a id="Update-Signals-1"></a><a class="docs-heading-anchor-permalink" href="#Update-Signals" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ClimaTimeSteppers.UpdateSignalHandler" href="#ClimaTimeSteppers.UpdateSignalHandler"><code>ClimaTimeSteppers.UpdateSignalHandler</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">UpdateSignalHandler</code></pre><p>A boolean indicating if updates a value upon receiving an appropriate <code>UpdateSignal</code>. This is done by calling <code>needs_update!(::UpdateSignalHandler, cache, ::UpdateSignal)</code>.</p><p>The <code>cache</code> can be obtained with <code>allocate_cache(::UpdateSignalHandler, FT)</code>, where <code>FT</code> is the floating-point type of the integrator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaTimeSteppers.jl/blob/32551d3c8f56b95a41a16005cc34a73a88e5a380/src/utilities/update_signal_handler.jl#L12-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaTimeSteppers.UpdateEvery" href="#ClimaTimeSteppers.UpdateEvery"><code>ClimaTimeSteppers.UpdateEvery</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">UpdateEvery(update_signal_type)</code></pre><p>An <code>UpdateSignalHandler</code> that performs the update whenever it is <code>needs_update!</code> with an <code>UpdateSignal</code> of type <code>update_signal_type</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaTimeSteppers.jl/blob/32551d3c8f56b95a41a16005cc34a73a88e5a380/src/utilities/update_signal_handler.jl#L50-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaTimeSteppers.UpdateEveryN" href="#ClimaTimeSteppers.UpdateEveryN"><code>ClimaTimeSteppers.UpdateEveryN</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">UpdateEveryN(n, update_signal_type, reset_signal_type = Nothing)</code></pre><p>An <code>UpdateSignalHandler</code> that performs the update every <code>n</code>-th time it is <code>needs_update!</code> with an <code>UpdateSignal</code> of type <code>update_signal_type</code>. If <code>reset_signal_type</code> is specified, then the counter (which gets incremented from 0 to <code>n</code> and then gets reset to 0 when it is time to perform another update) is reset to 0 whenever the signal handler is <code>needs_update!</code> with an <code>UpdateSignal</code> of type <code>reset_signal_type</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaTimeSteppers.jl/blob/32551d3c8f56b95a41a16005cc34a73a88e5a380/src/utilities/update_signal_handler.jl#L63-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaTimeSteppers.UpdateEveryDt" href="#ClimaTimeSteppers.UpdateEveryDt"><code>ClimaTimeSteppers.UpdateEveryDt</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">UpdateEveryDt(dt)</code></pre><p>An <code>UpdateSignalHandler</code> that performs the update whenever it is <code>needs_update!</code> with an <code>UpdateSignal</code> of type <code>NewTimeStep</code> and the difference between the current time and the previous update time is no less than <code>dt</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaTimeSteppers.jl/blob/32551d3c8f56b95a41a16005cc34a73a88e5a380/src/utilities/update_signal_handler.jl#L99-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaTimeSteppers.UpdateSignal" href="#ClimaTimeSteppers.UpdateSignal"><code>ClimaTimeSteppers.UpdateSignal</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">UpdateSignal</code></pre><p>A signal that gets passed to an <code>UpdateSignalHandler</code> whenever a certain operation is performed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaTimeSteppers.jl/blob/32551d3c8f56b95a41a16005cc34a73a88e5a380/src/utilities/update_signal_handler.jl#L4-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaTimeSteppers.NewTimeStep" href="#ClimaTimeSteppers.NewTimeStep"><code>ClimaTimeSteppers.NewTimeStep</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NewTimeStep(t)</code></pre><p>The signal for a new time step at time <code>t</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaTimeSteppers.jl/blob/32551d3c8f56b95a41a16005cc34a73a88e5a380/src/utilities/update_signal_handler.jl#L26-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaTimeSteppers.NewNewtonSolve" href="#ClimaTimeSteppers.NewNewtonSolve"><code>ClimaTimeSteppers.NewNewtonSolve</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NewNewtonSolve()</code></pre><p>The signal for a new <code>needs_update!</code> of Newton&#39;s method, which occurs on every implicit Runge-Kutta stage of the integrator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaTimeSteppers.jl/blob/32551d3c8f56b95a41a16005cc34a73a88e5a380/src/utilities/update_signal_handler.jl#L35-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaTimeSteppers.NewNewtonIteration" href="#ClimaTimeSteppers.NewNewtonIteration"><code>ClimaTimeSteppers.NewNewtonIteration</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NewNewtonIteration()</code></pre><p>The signal for a new iteration of Newton&#39;s method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaTimeSteppers.jl/blob/32551d3c8f56b95a41a16005cc34a73a88e5a380/src/utilities/update_signal_handler.jl#L43-L47">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tableaus/">« Tableaus</a><a class="docs-footer-nextpage" href="../callbacks/">Callbacks »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Thursday 12 January 2023 16:37">Thursday 12 January 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
